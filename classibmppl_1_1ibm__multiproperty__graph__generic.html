<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>IBM SYSTEMG G RUNTIME &amp; NATIVE STORE: ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IBM SYSTEMG G RUNTIME &amp; NATIVE STORE
   &#160;<span id="projectnumber">0.5</span>
   </div>
   <div id="projectbrief">IBM Native Graph Computing and Storage System based on IBM Parallel Programming Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibmppl</b></li><li class="navelem"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="classibmppl_1_1ibm__multiproperty__graph__generic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>IBM Multi property graph class to store multiple properties.  
 <a href="classibmppl_1_1ibm__multiproperty__graph__generic.html#details">More...</a></p>

<p><code>#include &lt;ibm_multiproperty_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classibmppl_1_1ibm__multiproperty__graph__generic.png" usemap="#ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt;_map" alt=""/>
  <map id="ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt;_map" name="ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt;_map">
<area href="classibmppl_1_1rdfGraph.html" alt="ibmppl::rdfGraph&lt; tabular_multiproperty_type, tabular_multiproperty_type, ST &gt;" shape="rect" coords="0,0,462,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a723782cd96926999cc235a8acf8f1654"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a723782cd96926999cc235a8acf8f1654"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a9e8eea64ca85317bc411a407312994ce">base_type::edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a></td></tr>
<tr class="memdesc:a723782cd96926999cc235a8acf8f1654"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibmppl_1_1Edge.html" title="Generic implementation of graph edge templated by Property type. ">Edge</a> descriptor or unique edge identifier. <br/></td></tr>
<tr class="separator:a723782cd96926999cc235a8acf8f1654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f0b05af94598497337a27f86cdc17a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57f0b05af94598497337a27f86cdc17a"></a>
typedef base_type::vertex_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a57f0b05af94598497337a27f86cdc17a">vertex_type</a></td></tr>
<tr class="memdesc:a57f0b05af94598497337a27f86cdc17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex class; storage for property and edges. <br/></td></tr>
<tr class="separator:a57f0b05af94598497337a27f86cdc17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b551724da5b275c5cdeb48da624d61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b551724da5b275c5cdeb48da624d61"></a>
typedef base_type::edge_type&#160;</td><td class="memItemRight" valign="bottom"><b>edge_type</b></td></tr>
<tr class="separator:a12b551724da5b275c5cdeb48da624d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4243ae01a238e356583fe77a2fbfa857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4243ae01a238e356583fe77a2fbfa857"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">base_type::vertexd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a></td></tr>
<tr class="memdesc:a4243ae01a238e356583fe77a2fbfa857"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibmppl_1_1Vertex.html" title="Generic implementation of graph vertex class w/ a list of edges and a vertex property. ">Vertex</a> descriptor. Unique vertex identifier. <br/></td></tr>
<tr class="separator:a4243ae01a238e356583fe77a2fbfa857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d529729143c23ef9bb7a805ff0ded88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d529729143c23ef9bb7a805ff0ded88"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a3f7b4ea34f7b34ad57c765e4a93dbe07">base_type::vertex_property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4d529729143c23ef9bb7a805ff0ded88">vertex_property</a></td></tr>
<tr class="memdesc:a4d529729143c23ef9bb7a805ff0ded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property type associated with each vertex. <br/></td></tr>
<tr class="separator:a4d529729143c23ef9bb7a805ff0ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ba627b686485b1de1236252823aa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a464ba627b686485b1de1236252823aa3"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a26faf086fbc17ee8078b327101d6d75b">base_type::edge_property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a464ba627b686485b1de1236252823aa3">edge_property</a></td></tr>
<tr class="memdesc:a464ba627b686485b1de1236252823aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property type associated with each edge. <br/></td></tr>
<tr class="separator:a464ba627b686485b1de1236252823aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659436d5d1391566687ece540b607ddd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a659436d5d1391566687ece540b607ddd"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a8252230bab32504447cd1ccab63148a9">base_type::edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a659436d5d1391566687ece540b607ddd">base_edge_iterator</a></td></tr>
<tr class="memdesc:a659436d5d1391566687ece540b607ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for traversing vertices. <br/></td></tr>
<tr class="separator:a659436d5d1391566687ece540b607ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee361eb6b98df4eb929e402af6fcc00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ee361eb6b98df4eb929e402af6fcc00"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">base_type::vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>base_vertex_iterator</b></td></tr>
<tr class="separator:a5ee361eb6b98df4eb929e402af6fcc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a9effa86877f901b24efee4a993704"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27a9effa86877f901b24efee4a993704"></a>
typedef base_type::pred_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>base_pred_iterator</b></td></tr>
<tr class="separator:a27a9effa86877f901b24efee4a993704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022234b7d92e807eb63cb690e03cd2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7022234b7d92e807eb63cb690e03cd2a"></a>
typedef <a class="el" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a57f0b05af94598497337a27f86cdc17a">vertex_type</a>, <br class="typebreak"/>
base_vertex_iterator, <br class="typebreak"/>
<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a05773970d54976b050e74d824c7bb9cb">this_type</a>, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_iterator</b></td></tr>
<tr class="separator:a7022234b7d92e807eb63cb690e03cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfff6941905a3f37c8d0a92bc746e62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdfff6941905a3f37c8d0a92bc746e62"></a>
typedef <a class="el" href="classibmppl_1_1imp__edge__iterator.html">imp_edge_iterator</a><br class="typebreak"/>
&lt; edge_type, <br class="typebreak"/>
<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a659436d5d1391566687ece540b607ddd">base_edge_iterator</a>, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a05773970d54976b050e74d824c7bb9cb">this_type</a>, <br class="typebreak"/>
<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge_iterator</b></td></tr>
<tr class="separator:abdfff6941905a3f37c8d0a92bc746e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967652d83a7b35dfa20296cdd7600426"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967652d83a7b35dfa20296cdd7600426"></a>
typedef <a class="el" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator</a><br class="typebreak"/>
&lt; edge_type, <br class="typebreak"/>
base_pred_iterator, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a05773970d54976b050e74d824c7bb9cb">this_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pred_iterator</b></td></tr>
<tr class="separator:a967652d83a7b35dfa20296cdd7600426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126ef1ac10d774bfc833fe1cabc604f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1126ef1ac10d774bfc833fe1cabc604f"></a>
typedef <br class="typebreak"/>
<a class="el" href="classibmppl_1_1omnidirectional__edge__iterator__t.html">omnidirectional_edge_iterator_t</a><br class="typebreak"/>
&lt; <a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>, <br class="typebreak"/>
<a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a05773970d54976b050e74d824c7bb9cb">this_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>omni_iterator</b></td></tr>
<tr class="separator:a1126ef1ac10d774bfc833fe1cabc604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3597954dbb6179b2c2ca3dacaf10b4e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3597954dbb6179b2c2ca3dacaf10b4e6"></a>
typedef <br class="typebreak"/>
<a class="el" href="classibmppl_1_1rdfGraph.html#aea3db4e401556f561516cd27aad54a4a">base_type::const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a3597954dbb6179b2c2ca3dacaf10b4e6">const_vertex_iterator</a></td></tr>
<tr class="memdesc:a3597954dbb6179b2c2ca3dacaf10b4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Iterator type for traversing edges. You won't be able to modify properties when using this iterator. <br/></td></tr>
<tr class="separator:a3597954dbb6179b2c2ca3dacaf10b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb55c1f39a7a34bc9044ffafd6be8eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb55c1f39a7a34bc9044ffafd6be8eac"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>property_name_type</b></td></tr>
<tr class="separator:adb55c1f39a7a34bc9044ffafd6be8eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b21fa56b2606d4379c541b93d88a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6b21fa56b2606d4379c541b93d88a93"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>property_value_type</b></td></tr>
<tr class="separator:af6b21fa56b2606d4379c541b93d88a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71131bdef9b60629dd727d40d9a79a6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71131bdef9b60629dd727d40d9a79a6a"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>label_string_type</b></td></tr>
<tr class="separator:a71131bdef9b60629dd727d40d9a79a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeef256187182fdaeb5f45d9933d598d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeef256187182fdaeb5f45d9933d598d"></a>
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>vclass_string_type</b></td></tr>
<tr class="separator:aaeef256187182fdaeb5f45d9933d598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af259f1611c889e396df440a833cc5ad5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af259f1611c889e396df440a833cc5ad5"></a>
typedef <br class="typebreak"/>
<a class="el" href="classibmppl_1_1mp__subproperty__iterator__t.html">mp_subproperty_iterator_t</a><br class="typebreak"/>
&lt; <a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>, <br class="typebreak"/>
<a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>property_iterator</b></td></tr>
<tr class="separator:af259f1611c889e396df440a833cc5ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classibmppl_1_1rdfGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classibmppl_1_1rdfGraph')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classibmppl_1_1rdfGraph.html">ibmppl::rdfGraph&lt; tabular_multiproperty_type, tabular_multiproperty_type, ST &gt;</a></td></tr>
<tr class="memitem:a9e8eea64ca85317bc411a407312994ce inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8eea64ca85317bc411a407312994ce"></a>
typedef base_type::edged_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a9e8eea64ca85317bc411a407312994ce">edged_type</a></td></tr>
<tr class="memdesc:a9e8eea64ca85317bc411a407312994ce inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge descriptor or unique edge identifier. <br/></td></tr>
<tr class="separator:a9e8eea64ca85317bc411a407312994ce inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a6eea13d8d0a0a4540289d2b56198d inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80a6eea13d8d0a0a4540289d2b56198d"></a>
typedef base_type::vertexd_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">vertexd_type</a></td></tr>
<tr class="memdesc:a80a6eea13d8d0a0a4540289d2b56198d inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex descriptor. Unique vertex identifier. <br/></td></tr>
<tr class="separator:a80a6eea13d8d0a0a4540289d2b56198d inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7b4ea34f7b34ad57c765e4a93dbe07 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7b4ea34f7b34ad57c765e4a93dbe07"></a>
typedef base_type::vertex_property&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a3f7b4ea34f7b34ad57c765e4a93dbe07">vertex_property</a></td></tr>
<tr class="memdesc:a3f7b4ea34f7b34ad57c765e4a93dbe07 inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property type associated with each vertex. <br/></td></tr>
<tr class="separator:a3f7b4ea34f7b34ad57c765e4a93dbe07 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26faf086fbc17ee8078b327101d6d75b inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26faf086fbc17ee8078b327101d6d75b"></a>
typedef base_type::edge_property&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a26faf086fbc17ee8078b327101d6d75b">edge_property</a></td></tr>
<tr class="memdesc:a26faf086fbc17ee8078b327101d6d75b inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property type associated with each edge. <br/></td></tr>
<tr class="separator:a26faf086fbc17ee8078b327101d6d75b inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e8b8a86e6ff9b323e7328deda41385 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e8b8a86e6ff9b323e7328deda41385"></a>
typedef base_type::vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">vertex_iterator</a></td></tr>
<tr class="memdesc:a89e8b8a86e6ff9b323e7328deda41385 inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for traversing vertices. <br/></td></tr>
<tr class="separator:a89e8b8a86e6ff9b323e7328deda41385 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3db4e401556f561516cd27aad54a4a inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_type::const_vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#aea3db4e401556f561516cd27aad54a4a">const_vertex_iterator</a></td></tr>
<tr class="separator:aea3db4e401556f561516cd27aad54a4a inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8252230bab32504447cd1ccab63148a9 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8252230bab32504447cd1ccab63148a9"></a>
typedef base_type::edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1rdfGraph.html#a8252230bab32504447cd1ccab63148a9">edge_iterator</a></td></tr>
<tr class="memdesc:a8252230bab32504447cd1ccab63148a9 inherit pub_types_classibmppl_1_1rdfGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge iterator <br/></td></tr>
<tr class="separator:a8252230bab32504447cd1ccab63148a9 inherit pub_types_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d81a2f53bce505613b81832ae511d58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4d81a2f53bce505613b81832ae511d58">ibm_multiproperty_graph_generic</a> (string filename, string path, UINT64 max_memsize=(UINT64)(4294967295), size_t el_blk_sz=DEFAULT_BUNDLE_SZ, size_t vp_blk_sz=DEFAULT_BUNDLE_SZ, size_t ep_blk_sz=DEFAULT_BUNDLE_SZ)</td></tr>
<tr class="memdesc:a4d81a2f53bce505613b81832ae511d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">IBM Multiporperty graph constructor.  <a href="#a4d81a2f53bce505613b81832ae511d58">More...</a><br/></td></tr>
<tr class="separator:a4d81a2f53bce505613b81832ae511d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e669ff851acdf4796faf4867896d56"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a81e669ff851acdf4796faf4867896d56">~ibm_multiproperty_graph_generic</a> ()</td></tr>
<tr class="memdesc:a81e669ff851acdf4796faf4867896d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">IBM Multiprpoerty graph destructor.  <a href="#a81e669ff851acdf4796faf4867896d56">More...</a><br/></td></tr>
<tr class="separator:a81e669ff851acdf4796faf4867896d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e2c66da8b31db8b0b9fed2d755ff7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a36e2c66da8b31db8b0b9fed2d755ff7b">vert_index_available</a> (size_t propid) const </td></tr>
<tr class="memdesc:a36e2c66da8b31db8b0b9fed2d755ff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method indicates if the named index exists. Currently the index name is the name of the vertex property that would be indexed. At the moment this class does not support edge properties.  <a href="#a36e2c66da8b31db8b0b9fed2d755ff7b">More...</a><br/></td></tr>
<tr class="separator:a36e2c66da8b31db8b0b9fed2d755ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9814917066d9a10b0bf8ad9c8d9c2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#adf9814917066d9a10b0bf8ad9c8d9c2e">vert_index_available_we</a> (size_t propid) const </td></tr>
<tr class="memdesc:adf9814917066d9a10b0bf8ad9c8d9c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is like <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a36e2c66da8b31db8b0b9fed2d755ff7b" title="This method indicates if the named index exists. Currently the index name is the name of the vertex p...">vert_index_available()</a> but it will throw an out_of_range exception if the propid is beyond the highest index we're supporting. This will help the calling code to enumerate indices.  <a href="#adf9814917066d9a10b0bf8ad9c8d9c2e">More...</a><br/></td></tr>
<tr class="separator:adf9814917066d9a10b0bf8ad9c8d9c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e7266a0febc54e471ea2e43957f4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac82e7266a0febc54e471ea2e43957f4e">index_find</a> (int propid, const property_value_type &amp;pval, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &amp;vid)</td></tr>
<tr class="memdesc:ac82e7266a0febc54e471ea2e43957f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows the caller to find the vid of a vertex that has the given value on the given property.  <a href="#ac82e7266a0febc54e471ea2e43957f4e">More...</a><br/></td></tr>
<tr class="separator:ac82e7266a0febc54e471ea2e43957f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edf7328f3660d75146b780bb02f2be2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a5edf7328f3660d75146b780bb02f2be2">index_find_all</a> (int propid, const property_value_type &amp;pval, std::vector&lt; <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; &amp;vids)</td></tr>
<tr class="memdesc:a5edf7328f3660d75146b780bb02f2be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows the caller to find all the vertices that have the given value on the given property. Warning: it will crash if there is no index. Check for that using the "available" method.  <a href="#a5edf7328f3660d75146b780bb02f2be2">More...</a><br/></td></tr>
<tr class="separator:a5edf7328f3660d75146b780bb02f2be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496b5277cc15f9dff150c0e71732d72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab496b5277cc15f9dff150c0e71732d72">find_all</a> (int propid, const property_value_type &amp;pval, std::vector&lt; <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; &amp;vids)</td></tr>
<tr class="memdesc:ab496b5277cc15f9dff150c0e71732d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows the caller to find all the vertices that have the given value on the given property. This version will not die if the index doesn't exist. Instead it will slowly generate the response after printing a warning message.  <a href="#ab496b5277cc15f9dff150c0e71732d72">More...</a><br/></td></tr>
<tr class="separator:ab496b5277cc15f9dff150c0e71732d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5561782353d3eac48f5a4008c86f6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8b5561782353d3eac48f5a4008c86f6e">_index_insert</a> (int propid, const property_value_type &amp;pval, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid)</td></tr>
<tr class="memdesc:a8b5561782353d3eac48f5a4008c86f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a method that most people should not use. It's used internally to keep the index up to date.  <a href="#a8b5561782353d3eac48f5a4008c86f6e">More...</a><br/></td></tr>
<tr class="separator:a8b5561782353d3eac48f5a4008c86f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0840ee6fa0aeced4b920420dbc409f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac0840ee6fa0aeced4b920420dbc409f0">index_erasexx</a> (int propid, const property_value_type &amp;pval)</td></tr>
<tr class="memdesc:ac0840ee6fa0aeced4b920420dbc409f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a method that most people should not use. It's used internally to keep the index up to date.  <a href="#ac0840ee6fa0aeced4b920420dbc409f0">More...</a><br/></td></tr>
<tr class="separator:ac0840ee6fa0aeced4b920420dbc409f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f6da301fd8da8c3cf535311d07fa74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a79f6da301fd8da8c3cf535311d07fa74">index_erase</a> (int propid, const property_value_type &amp;pval, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid)</td></tr>
<tr class="memdesc:a79f6da301fd8da8c3cf535311d07fa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a method that most people should not use. It's used internally to keep the index up to date.  <a href="#a79f6da301fd8da8c3cf535311d07fa74">More...</a><br/></td></tr>
<tr class="separator:a79f6da301fd8da8c3cf535311d07fa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5b461bdd39b758ecd1480316d267a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5b461bdd39b758ecd1480316d267a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>index_erase</b> (int propid, char const *pval, int pvallen, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid)</td></tr>
<tr class="separator:afa5b461bdd39b758ecd1480316d267a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2905ea6148bea170d916bececcecfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a0d2905ea6148bea170d916bececcecfd">add_index</a> (const property_name_type &amp;pname, bool is_multi=false)</td></tr>
<tr class="memdesc:a0d2905ea6148bea170d916bececcecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates an index on the specified property and property value.  <a href="#a0d2905ea6148bea170d916bececcecfd">More...</a><br/></td></tr>
<tr class="separator:a0d2905ea6148bea170d916bececcecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8eac708a7927d635ce1a442f4f6413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acb8eac708a7927d635ce1a442f4f6413">set_esubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> eid, const property_name_type &amp;pname, const property_value_type &amp;value)</td></tr>
<tr class="memdesc:acb8eac708a7927d635ce1a442f4f6413"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a property to an edge.  <a href="#acb8eac708a7927d635ce1a442f4f6413">More...</a><br/></td></tr>
<tr class="separator:acb8eac708a7927d635ce1a442f4f6413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd27bb8ad2e23eb44e90b6b1e6b687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aaffd27bb8ad2e23eb44e90b6b1e6b687">set_esubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> eid, const size_t propid, const property_value_type &amp;value)</td></tr>
<tr class="memdesc:aaffd27bb8ad2e23eb44e90b6b1e6b687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a property to an edge.  <a href="#aaffd27bb8ad2e23eb44e90b6b1e6b687">More...</a><br/></td></tr>
<tr class="separator:aaffd27bb8ad2e23eb44e90b6b1e6b687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c689c7019abbfd21b7004edffc68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a495c689c7019abbfd21b7004edffc68e">set_vsubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid, const property_name_type &amp;pname, const property_value_type &amp;value)</td></tr>
<tr class="memdesc:a495c689c7019abbfd21b7004edffc68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified property for the specified vertex to the specified string value.  <a href="#a495c689c7019abbfd21b7004edffc68e">More...</a><br/></td></tr>
<tr class="separator:a495c689c7019abbfd21b7004edffc68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b54de7b66b679bf4705d0926f91e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae1b54de7b66b679bf4705d0926f91e96">set_vsubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid, const size_t propid, const property_value_type &amp;value)</td></tr>
<tr class="memdesc:ae1b54de7b66b679bf4705d0926f91e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified property for the specified vertex to the specified string value.  <a href="#ae1b54de7b66b679bf4705d0926f91e96">More...</a><br/></td></tr>
<tr class="separator:ae1b54de7b66b679bf4705d0926f91e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544b5621faf5a29ebd355c256a3cdd96"><td class="memItemLeft" align="right" valign="top">property_value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a544b5621faf5a29ebd355c256a3cdd96">get_vsubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid, const property_name_type &amp;pname)</td></tr>
<tr class="memdesc:a544b5621faf5a29ebd355c256a3cdd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified property for the specified vertex.  <a href="#a544b5621faf5a29ebd355c256a3cdd96">More...</a><br/></td></tr>
<tr class="separator:a544b5621faf5a29ebd355c256a3cdd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddfe41c9c823e879f3e653918e86e7e"><td class="memItemLeft" align="right" valign="top">property_value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a3ddfe41c9c823e879f3e653918e86e7e">get_vsubproperty</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid, size_t propid)</td></tr>
<tr class="separator:a3ddfe41c9c823e879f3e653918e86e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c35a232c23c1fd9fde1d44280cacf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac27c35a232c23c1fd9fde1d44280cacf">get_or_allocate_epropertyid</a> (const property_name_type &amp;pname)</td></tr>
<tr class="memdesc:ac27c35a232c23c1fd9fde1d44280cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified edge property-name to it's property-id.  <a href="#ac27c35a232c23c1fd9fde1d44280cacf">More...</a><br/></td></tr>
<tr class="separator:ac27c35a232c23c1fd9fde1d44280cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ae1880dc0ea90b5d57fe615675f724"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a31ae1880dc0ea90b5d57fe615675f724">get_or_allocate_vpropertyid</a> (const property_name_type &amp;pname)</td></tr>
<tr class="memdesc:a31ae1880dc0ea90b5d57fe615675f724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified vertex property-name to it's property-id.  <a href="#a31ae1880dc0ea90b5d57fe615675f724">More...</a><br/></td></tr>
<tr class="separator:a31ae1880dc0ea90b5d57fe615675f724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb515737948cd963db684c951a1e907"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8bb515737948cd963db684c951a1e907">get_or_allocate_labelid</a> (const label_string_type &amp;labelstr)</td></tr>
<tr class="memdesc:a8bb515737948cd963db684c951a1e907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified label name to it's label-id.  <a href="#a8bb515737948cd963db684c951a1e907">More...</a><br/></td></tr>
<tr class="separator:a8bb515737948cd963db684c951a1e907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569997ddc56fe573ff409e017cab742"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9569997ddc56fe573ff409e017cab742"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_or_allocate_vclassid</b> (const vclass_string_type &amp;vclassname)</td></tr>
<tr class="separator:a9569997ddc56fe573ff409e017cab742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93af8b201084c791c37dd18ffda4d12f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a93af8b201084c791c37dd18ffda4d12f">get_labelid</a> (const label_string_type &amp;labelstr, size_t &amp;retval)</td></tr>
<tr class="memdesc:a93af8b201084c791c37dd18ffda4d12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified label name to it's label-id.  <a href="#a93af8b201084c791c37dd18ffda4d12f">More...</a><br/></td></tr>
<tr class="separator:a93af8b201084c791c37dd18ffda4d12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ff9df0c0da12cf3aca16933899dee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ff9df0c0da12cf3aca16933899dee7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_vclassid</b> (const vclass_string_type &amp;vclassname, size_t &amp;retval)</td></tr>
<tr class="separator:a73ff9df0c0da12cf3aca16933899dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f00c7a993162b7fc47938958bdd985"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae8f00c7a993162b7fc47938958bdd985">get_epropertyid</a> (const property_name_type &amp;pname)</td></tr>
<tr class="memdesc:ae8f00c7a993162b7fc47938958bdd985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified edge property-name to it's property-id.  <a href="#ae8f00c7a993162b7fc47938958bdd985">More...</a><br/></td></tr>
<tr class="separator:ae8f00c7a993162b7fc47938958bdd985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e7c28d996539890b1a67b45871103"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a824e7c28d996539890b1a67b45871103">get_edge_property_name</a> (const size_t propid) const </td></tr>
<tr class="memdesc:a824e7c28d996539890b1a67b45871103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified edge property-id to it's property name.  <a href="#a824e7c28d996539890b1a67b45871103">More...</a><br/></td></tr>
<tr class="separator:a824e7c28d996539890b1a67b45871103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b9d9c704224b683e8b73ca36be1bd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a57b9d9c704224b683e8b73ca36be1bd0">get_edge_property_count</a> () const </td></tr>
<tr class="memdesc:a57b9d9c704224b683e8b73ca36be1bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number or propertynames found edge in the graph. The caller can follow this up by calling get_property_name() from 0 .. ((returned value-1)) Values 0, 1... are reserved pseudo-properties, so the caller might chose to skip these and start with the CSVP_PROPERTIES_FIRST_NON_PSEUDO_PROPERTY property.  <a href="#a57b9d9c704224b683e8b73ca36be1bd0">More...</a><br/></td></tr>
<tr class="separator:a57b9d9c704224b683e8b73ca36be1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5150345ed560ac93a0a7431d7ce2b33c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a5150345ed560ac93a0a7431d7ce2b33c">get_vpropertyid</a> (const property_name_type &amp;pname)</td></tr>
<tr class="memdesc:a5150345ed560ac93a0a7431d7ce2b33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified vertex property-name to it's property-id.  <a href="#a5150345ed560ac93a0a7431d7ce2b33c">More...</a><br/></td></tr>
<tr class="separator:a5150345ed560ac93a0a7431d7ce2b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8499115382af4c0f52601231207e68e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac8499115382af4c0f52601231207e68e">get_vertex_property_name</a> (const size_t propid) const </td></tr>
<tr class="memdesc:ac8499115382af4c0f52601231207e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified vertex property-id to it's property value.  <a href="#ac8499115382af4c0f52601231207e68e">More...</a><br/></td></tr>
<tr class="separator:ac8499115382af4c0f52601231207e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6614a7c13e9a5387cfcd398f1c0e5d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a6614a7c13e9a5387cfcd398f1c0e5d0a">get_vertex_property_count</a> () const </td></tr>
<tr class="memdesc:a6614a7c13e9a5387cfcd398f1c0e5d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number or propertynames found vertices in the graph. The caller can follow this up by calling get_property_name() from 0 .. ((returned value-1)) Values 0, 1... are reserved pseudo-properties, so the caller might chose to skip these and start with the CSVP_PROPERTIES_FIRST_NON_PSEUDO_PROPERTY property.  <a href="#a6614a7c13e9a5387cfcd398f1c0e5d0a">More...</a><br/></td></tr>
<tr class="separator:a6614a7c13e9a5387cfcd398f1c0e5d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec84cb6d7f6945e59e0c2c4976ca54"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a6dec84cb6d7f6945e59e0c2c4976ca54">get_labelid</a> (const label_string_type &amp;labelstr)</td></tr>
<tr class="memdesc:a6dec84cb6d7f6945e59e0c2c4976ca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified label string to it's label-id.  <a href="#a6dec84cb6d7f6945e59e0c2c4976ca54">More...</a><br/></td></tr>
<tr class="separator:a6dec84cb6d7f6945e59e0c2c4976ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe6654a6328c0626757baeec9e7c1a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fe6654a6328c0626757baeec9e7c1a4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_vclassid</b> (const vclass_string_type &amp;vclassname)</td></tr>
<tr class="separator:a0fe6654a6328c0626757baeec9e7c1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9073965031afdb930a81ae1a97aa0c0e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9073965031afdb930a81ae1a97aa0c0e">get_label_string</a> (const size_t labelid) const </td></tr>
<tr class="memdesc:a9073965031afdb930a81ae1a97aa0c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a specified label-id it's label string.  <a href="#a9073965031afdb930a81ae1a97aa0c0e">More...</a><br/></td></tr>
<tr class="separator:a9073965031afdb930a81ae1a97aa0c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92a88804b73231122eed9b38f306bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab92a88804b73231122eed9b38f306bcc"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>get_vclassname</b> (size_t vclassid)</td></tr>
<tr class="separator:ab92a88804b73231122eed9b38f306bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03ccac10df93b48d956a426a304f6ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad03ccac10df93b48d956a426a304f6ff"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>deprecated_get_vclassname_as_stdstring</b> (size_t vclassid)</td></tr>
<tr class="separator:ad03ccac10df93b48d956a426a304f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459b972031834a0800ec75ebcdb1f9cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a459b972031834a0800ec75ebcdb1f9cc"></a>
char const *&#160;</td><td class="memItemRight" valign="bottom"><b>get_external_id_as_cstr</b> (size_t vid)</td></tr>
<tr class="separator:a459b972031834a0800ec75ebcdb1f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab5a509d7a21f64917a43c1fa9a699"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9ab5a509d7a21f64917a43c1fa9a699"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>deprecated_get_external_id_as_stdstring</b> (size_t vid)</td></tr>
<tr class="separator:ae9ab5a509d7a21f64917a43c1fa9a699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e66d72ed1a3aff69375e4a0ea61396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a78e66d72ed1a3aff69375e4a0ea61396">find_vertex</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid)</td></tr>
<tr class="memdesc:a78e66d72ed1a3aff69375e4a0ea61396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first vertex with a given vertex id.  <a href="#a78e66d72ed1a3aff69375e4a0ea61396">More...</a><br/></td></tr>
<tr class="separator:a78e66d72ed1a3aff69375e4a0ea61396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c2ce19f6109a3f6352b21465e64e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae5c2ce19f6109a3f6352b21465e64e6d">find_edge</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> eid)</td></tr>
<tr class="memdesc:ae5c2ce19f6109a3f6352b21465e64e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first edge for a given vertex with a given edge id.  <a href="#ae5c2ce19f6109a3f6352b21465e64e6d">More...</a><br/></td></tr>
<tr class="separator:ae5c2ce19f6109a3f6352b21465e64e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6365310ff63de7a9c732ef354a9f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9e6365310ff63de7a9c732ef354a9f76">find_vertex</a> (const property_name_type &amp;pname, const property_value_type &amp;pval)</td></tr>
<tr class="memdesc:a9e6365310ff63de7a9c732ef354a9f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first vertex with a given property value.  <a href="#a9e6365310ff63de7a9c732ef354a9f76">More...</a><br/></td></tr>
<tr class="separator:a9e6365310ff63de7a9c732ef354a9f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab27a14f057502c251cbdbad22507c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ab27a14f057502c251cbdbad22507c"></a>
<a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_begin</b> ()</td></tr>
<tr class="separator:a79ab27a14f057502c251cbdbad22507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e30fa014e87c5e709a02ab6d4666d28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e30fa014e87c5e709a02ab6d4666d28"></a>
<a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_end</b> ()</td></tr>
<tr class="separator:a4e30fa014e87c5e709a02ab6d4666d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da6c1d5dc0ad1870cc1903c538e01bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a6da6c1d5dc0ad1870cc1903c538e01bd">delete_vertex</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vid)</td></tr>
<tr class="memdesc:a6da6c1d5dc0ad1870cc1903c538e01bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes specified vertex and adjacent edges.  <a href="#a6da6c1d5dc0ad1870cc1903c538e01bd">More...</a><br/></td></tr>
<tr class="separator:a6da6c1d5dc0ad1870cc1903c538e01bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea5147c920bb1a7b574f2f6eb7e65d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea5147c920bb1a7b574f2f6eb7e65d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_vertex</b> (char const *exid, int exidlen)</td></tr>
<tr class="separator:afea5147c920bb1a7b574f2f6eb7e65d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6ef51763deb6d1c487e15ee6594a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abf6ef51763deb6d1c487e15ee6594a4b">add_vertex</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4d529729143c23ef9bb7a805ff0ded88">vertex_property</a> &amp;vp)</td></tr>
<tr class="memdesc:abf6ef51763deb6d1c487e15ee6594a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex to the graph.  <a href="#abf6ef51763deb6d1c487e15ee6594a4b">More...</a><br/></td></tr>
<tr class="separator:abf6ef51763deb6d1c487e15ee6594a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e32530fb68e5653240883dd0cca486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a98e32530fb68e5653240883dd0cca486">add_vertex</a> (size_t vclassid)</td></tr>
<tr class="memdesc:a98e32530fb68e5653240883dd0cca486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex to the graph.  <a href="#a98e32530fb68e5653240883dd0cca486">More...</a><br/></td></tr>
<tr class="separator:a98e32530fb68e5653240883dd0cca486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920dd12971badb795439a45e2d10cba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a920dd12971badb795439a45e2d10cba4">add_vertex</a> (size_t vclassid, char const *exid, int exidlen)</td></tr>
<tr class="memdesc:a920dd12971badb795439a45e2d10cba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vertex  <a href="#a920dd12971badb795439a45e2d10cba4">More...</a><br/></td></tr>
<tr class="separator:a920dd12971badb795439a45e2d10cba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746e0fcade63422e52fb3606aba18600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a746e0fcade63422e52fb3606aba18600">add_vertexxxx</a> (property_value_type &amp;value)</td></tr>
<tr class="memdesc:a746e0fcade63422e52fb3606aba18600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex to the graph.  <a href="#a746e0fcade63422e52fb3606aba18600">More...</a><br/></td></tr>
<tr class="separator:a746e0fcade63422e52fb3606aba18600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505558098acbbf58f9c6e633b14e53d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a505558098acbbf58f9c6e633b14e53d3">add_edge</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vsource, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vtarget, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a464ba627b686485b1de1236252823aa3">edge_property</a> ep)</td></tr>
<tr class="memdesc:a505558098acbbf58f9c6e633b14e53d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to the graph.  <a href="#a505558098acbbf58f9c6e633b14e53d3">More...</a><br/></td></tr>
<tr class="separator:a505558098acbbf58f9c6e633b14e53d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5968912df055d6e20af931056f0418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aad5968912df055d6e20af931056f0418">add_edge</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vsource, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vtarget, size_t lid)</td></tr>
<tr class="separator:aad5968912df055d6e20af931056f0418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52281f7c722d7ea91ae72c60790b30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa52281f7c722d7ea91ae72c60790b30b">add_edge</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vsource, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vtarget, std::string label)</td></tr>
<tr class="separator:aa52281f7c722d7ea91ae72c60790b30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8aa1b62befe5ba8aa661206f12a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a63b8aa1b62befe5ba8aa661206f12a3e">add_edge_ref</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vsource, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vtarget, size_t lid)</td></tr>
<tr class="memdesc:a63b8aa1b62befe5ba8aa661206f12a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to the graph.  <a href="#a63b8aa1b62befe5ba8aa661206f12a3e">More...</a><br/></td></tr>
<tr class="separator:a63b8aa1b62befe5ba8aa661206f12a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfcc846081131827b83140660126416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8dfcc846081131827b83140660126416">add_edge_ref</a> (<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vsource, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> vtarget, std::string label)</td></tr>
<tr class="memdesc:a8dfcc846081131827b83140660126416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to the graph.  <a href="#a8dfcc846081131827b83140660126416">More...</a><br/></td></tr>
<tr class="separator:a8dfcc846081131827b83140660126416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classibmppl_1_1rdfGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classibmppl_1_1rdfGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classibmppl_1_1rdfGraph.html">ibmppl::rdfGraph&lt; tabular_multiproperty_type, tabular_multiproperty_type, ST &gt;</a></td></tr>
<tr class="memitem:ac5bb97a39460d9ca07f7f6d1c42b4a1b inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5bb97a39460d9ca07f7f6d1c42b4a1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rdfGraph</b> (const <a class="el" href="structibmppl_1_1graph__config.html">graph_config</a> &amp;gc=<a class="el" href="structibmppl_1_1graph__config.html">graph_config</a>())</td></tr>
<tr class="separator:ac5bb97a39460d9ca07f7f6d1c42b4a1b inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45983de9af6a822fd6d4bd91c946651 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad45983de9af6a822fd6d4bd91c946651"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_begin</b> ()</td></tr>
<tr class="separator:ad45983de9af6a822fd6d4bd91c946651 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48964c8126fe0bb655581dd2f976e293 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48964c8126fe0bb655581dd2f976e293"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#aea3db4e401556f561516cd27aad54a4a">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_begin</b> () const</td></tr>
<tr class="separator:a48964c8126fe0bb655581dd2f976e293 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305e9f2c379f426997ce11c6c0d96a9 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9305e9f2c379f426997ce11c6c0d96a9"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_begin</b> (size_t lid)</td></tr>
<tr class="separator:a9305e9f2c379f426997ce11c6c0d96a9 inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532eb234bd66ef7ce61cfb887077bc0c inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a532eb234bd66ef7ce61cfb887077bc0c"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_end</b> ()</td></tr>
<tr class="separator:a532eb234bd66ef7ce61cfb887077bc0c inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07f0ed1e0faf022c8df5896707cede inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a07f0ed1e0faf022c8df5896707cede"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#aea3db4e401556f561516cd27aad54a4a">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_end</b> () const</td></tr>
<tr class="separator:a5a07f0ed1e0faf022c8df5896707cede inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150e453f4c2a5f8baf7b79549ea1bbd inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9150e453f4c2a5f8baf7b79549ea1bbd"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a89e8b8a86e6ff9b323e7328deda41385">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_end</b> (size_t lid)</td></tr>
<tr class="separator:a9150e453f4c2a5f8baf7b79549ea1bbd inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77380637f60f5200120976a938de9e7c inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77380637f60f5200120976a938de9e7c"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a9e8eea64ca85317bc411a407312994ce">edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_edge</b> (<a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">vertexd_type</a> s, <a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">vertexd_type</a> t, const <a class="el" href="classibmppl_1_1rdfGraph.html#a26faf086fbc17ee8078b327101d6d75b">edge_property</a> &amp;ep)</td></tr>
<tr class="separator:a77380637f60f5200120976a938de9e7c inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b549262adf381425f69c208dc4c4e4f inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b549262adf381425f69c208dc4c4e4f"></a>
<a class="el" href="classibmppl_1_1rdfGraph.html#a8252230bab32504447cd1ccab63148a9">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_edge_ref</b> (<a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">vertexd_type</a> s, <a class="el" href="classibmppl_1_1rdfGraph.html#a80a6eea13d8d0a0a4540289d2b56198d">vertexd_type</a> t, const <a class="el" href="classibmppl_1_1rdfGraph.html#a26faf086fbc17ee8078b327101d6d75b">edge_property</a> &amp;ep)</td></tr>
<tr class="separator:a5b549262adf381425f69c208dc4c4e4f inherit pub_methods_classibmppl_1_1rdfGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a212bd89c011eb40c84f8f427727f3a0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a212bd89c011eb40c84f8f427727f3a0c"></a>
typedef index&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b></td></tr>
<tr class="separator:a212bd89c011eb40c84f8f427727f3a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2d6c572b5a10b7fd4bbf4cedc90c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adad2d6c572b5a10b7fd4bbf4cedc90c0"></a>
typedef std::vector<br class="typebreak"/>
&lt; index_type * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>index_iterator</b></td></tr>
<tr class="separator:adad2d6c572b5a10b7fd4bbf4cedc90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae82fb0bb5ac98aff8419210aa6fea342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae82fb0bb5ac98aff8419210aa6fea342">_load_keys</a> (std::string fn, std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *vvec, std::vector&lt; std::string &gt; *revmap=0)</td></tr>
<tr class="memdesc:ae82fb0bb5ac98aff8419210aa6fea342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routine for reloading mappings between property-id's and property-name's.  <a href="#ae82fb0bb5ac98aff8419210aa6fea342">More...</a><br/></td></tr>
<tr class="separator:ae82fb0bb5ac98aff8419210aa6fea342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0dc7f5d775a3d646e1f792085db888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a7e0dc7f5d775a3d646e1f792085db888">_load_keys</a> ()</td></tr>
<tr class="memdesc:a7e0dc7f5d775a3d646e1f792085db888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routine for reloading mappings between property-id's and property-name's.  <a href="#a7e0dc7f5d775a3d646e1f792085db888">More...</a><br/></td></tr>
<tr class="separator:a7e0dc7f5d775a3d646e1f792085db888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bb06021df4fbaa11e9eb89faca6eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae3bb06021df4fbaa11e9eb89faca6eb2">_save_keys</a> (std::string fn, std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *vvec)</td></tr>
<tr class="memdesc:ae3bb06021df4fbaa11e9eb89faca6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routine for persisting mappings between property-id's and property-name's.  <a href="#ae3bb06021df4fbaa11e9eb89faca6eb2">More...</a><br/></td></tr>
<tr class="separator:ae3bb06021df4fbaa11e9eb89faca6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb69f593d95e73eb81d696f8c30a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a37bb69f593d95e73eb81d696f8c30a44">_save_keys</a> ()</td></tr>
<tr class="memdesc:a37bb69f593d95e73eb81d696f8c30a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routine for persisting mappings between property-id's and property-name's.  <a href="#a37bb69f593d95e73eb81d696f8c30a44">More...</a><br/></td></tr>
<tr class="separator:a37bb69f593d95e73eb81d696f8c30a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5272633ab205fd0af8b1b693dea123f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af5272633ab205fd0af8b1b693dea123f">_get_or_alloc_map</a> (std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *mapin, std::vector&lt; std::string &gt; *vecin, std::string keystring)</td></tr>
<tr class="memdesc:af5272633ab205fd0af8b1b693dea123f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper routine for get_or_allocXXXX() methods.  <a href="#af5272633ab205fd0af8b1b693dea123f">More...</a><br/></td></tr>
<tr class="separator:af5272633ab205fd0af8b1b693dea123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dab70a5ffd38de7f31cf7a6521cae3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a63dab70a5ffd38de7f31cf7a6521cae3">_get_mapping</a> (std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *mapin, std::string keystring)</td></tr>
<tr class="memdesc:a63dab70a5ffd38de7f31cf7a6521cae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper routine to help implement get_Xpropertyid() methods.  <a href="#a63dab70a5ffd38de7f31cf7a6521cae3">More...</a><br/></td></tr>
<tr class="separator:a63dab70a5ffd38de7f31cf7a6521cae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5737c0d8b4941cd38762645aafc5bf81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5737c0d8b4941cd38762645aafc5bf81"></a>
std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a5737c0d8b4941cd38762645aafc5bf81">vpropname_to_id</a></td></tr>
<tr class="memdesc:a5737c0d8b4941cd38762645aafc5bf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a property name to a property id. <br/></td></tr>
<tr class="separator:a5737c0d8b4941cd38762645aafc5bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f28d1abc9045a343ac1e7b7aa2bb808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f28d1abc9045a343ac1e7b7aa2bb808"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4f28d1abc9045a343ac1e7b7aa2bb808">id_to_vpropname</a></td></tr>
<tr class="memdesc:a4f28d1abc9045a343ac1e7b7aa2bb808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a property id to a property name(string) <br/></td></tr>
<tr class="separator:a4f28d1abc9045a343ac1e7b7aa2bb808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff842b88871de25156f6703a4e2255"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59ff842b88871de25156f6703a4e2255"></a>
std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a59ff842b88871de25156f6703a4e2255">epropname_to_id</a></td></tr>
<tr class="memdesc:a59ff842b88871de25156f6703a4e2255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar as above for edges. <br/></td></tr>
<tr class="separator:a59ff842b88871de25156f6703a4e2255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a15d9b096e18b52a028fa709ca3b7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3a15d9b096e18b52a028fa709ca3b7d"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>id_to_epropname</b></td></tr>
<tr class="separator:ab3a15d9b096e18b52a028fa709ca3b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4e79b2955a60abafc1e3e19fc1abf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e4e79b2955a60abafc1e3e19fc1abf8"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a3e4e79b2955a60abafc1e3e19fc1abf8">id_to_label</a></td></tr>
<tr class="memdesc:a3e4e79b2955a60abafc1e3e19fc1abf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a label id to a label string. <br/></td></tr>
<tr class="separator:a3e4e79b2955a60abafc1e3e19fc1abf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea7769ba7f49fe65de2ed7734d75790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea7769ba7f49fe65de2ed7734d75790"></a>
std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a7ea7769ba7f49fe65de2ed7734d75790">label_to_id</a></td></tr>
<tr class="memdesc:a7ea7769ba7f49fe65de2ed7734d75790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a label string to a label id. <br/></td></tr>
<tr class="separator:a7ea7769ba7f49fe65de2ed7734d75790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47cca68d32711dc05ec41ee01d84736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac47cca68d32711dc05ec41ee01d84736"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac47cca68d32711dc05ec41ee01d84736">vclassid_to_vclassname</a></td></tr>
<tr class="memdesc:ac47cca68d32711dc05ec41ee01d84736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a label id to a label string. <br/></td></tr>
<tr class="separator:ac47cca68d32711dc05ec41ee01d84736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8470c43ca750f48524678e786e0a423e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8470c43ca750f48524678e786e0a423e"></a>
std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8470c43ca750f48524678e786e0a423e">vclassname_to_vclassid</a></td></tr>
<tr class="memdesc:a8470c43ca750f48524678e786e0a423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a label string to a label id. <br/></td></tr>
<tr class="separator:a8470c43ca750f48524678e786e0a423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d641ea19339a04e205129dbf7a4a088"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d641ea19339a04e205129dbf7a4a088"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>store_name</b></td></tr>
<tr class="separator:a5d641ea19339a04e205129dbf7a4a088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0bf7a537d803ef41f3b396f1e1fb27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac0bf7a537d803ef41f3b396f1e1fb27"></a>
std::vector&lt; index_type * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vert_indices</b></td></tr>
<tr class="separator:aac0bf7a537d803ef41f3b396f1e1fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcd2f8a7c66e83cb028be42526fe93a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcd2f8a7c66e83cb028be42526fe93a"></a>
<a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eitCached</b></td></tr>
<tr class="separator:a3bcd2f8a7c66e83cb028be42526fe93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8bb2ef82f7b5c50944cdfb7c9b3ef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b8bb2ef82f7b5c50944cdfb7c9b3ef8"></a>
<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eitCachedEid</b></td></tr>
<tr class="separator:a2b8bb2ef82f7b5c50944cdfb7c9b3ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a07e2b6a940e0161defdc721ac0f70cec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07e2b6a940e0161defdc721ac0f70cec"></a>
typedef <a class="el" href="classibmppl_1_1rdfGraph.html">rdfGraph</a><br class="typebreak"/>
&lt; tabular_multiproperty_type, <br class="typebreak"/>
tabular_multiproperty_type, ST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a07e2b6a940e0161defdc721ac0f70cec">base_type</a></td></tr>
<tr class="memdesc:a07e2b6a940e0161defdc721ac0f70cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class type. <br/></td></tr>
<tr class="separator:a07e2b6a940e0161defdc721ac0f70cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05773970d54976b050e74d824c7bb9cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05773970d54976b050e74d824c7bb9cb"></a>
typedef <br class="typebreak"/>
<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic</a><br class="typebreak"/>
&lt; ST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a05773970d54976b050e74d824c7bb9cb">this_type</a></td></tr>
<tr class="memdesc:a05773970d54976b050e74d824c7bb9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self type. <br/></td></tr>
<tr class="separator:a05773970d54976b050e74d824c7bb9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;STORAGE_TYPE ST&gt;<br/>
class ibmppl::ibm_multiproperty_graph_generic&lt; ST &gt;</h3>

<p>IBM Multi property graph class to store multiple properties. </p>
<p>IBM Multi property graph class; It maintains an associative table (hash table) for individual properties; All properties are stored as strings : &lt;property_name:int, property_value:string&gt; A secondary table maps from property_name as string to property name as integer </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4d81a2f53bce505613b81832ae511d58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>max_memsize</em> = <code>(UINT64)(4294967295)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>el_blk_sz</em> = <code>DEFAULT_BUNDLE_SZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vp_blk_sz</em> = <code>DEFAULT_BUNDLE_SZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ep_blk_sz</em> = <code>DEFAULT_BUNDLE_SZ</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IBM Multiporperty graph constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the base filename in the directory specified in the path parameter. If they don't exist, this method will create a variety of files that start with this filename. Together they'll represent a graph. Initially it will be an empty graph.</td></tr>
    <tr><td class="paramname">path</td><td>the path of the file name </td></tr>
    <tr><td class="paramname">max_memsize</td><td>The maxmium number of bytes of RAM to use to service the graph requests. Far more space might be used on disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>
<p>This method returns a vector of index names. Right now the index names are the name of the property indexed. And at the moment only vertex properties are indexable.</p>

</div>
</div>
<a class="anchor" id="a81e669ff851acdf4796faf4867896d56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::~<a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IBM Multiprpoerty graph destructor. </p>
<p>It is important that this method be called. It will do things like save meta-data on the graph and deallocate some underlying structures.</p>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a63dab70a5ffd38de7f31cf7a6521cae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_get_mapping </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *&#160;</td>
          <td class="paramname"><em>mapin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keystring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper routine to help implement get_Xpropertyid() methods. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t the property id for the specified property name </dd></dl>

</div>
</div>
<a class="anchor" id="af5272633ab205fd0af8b1b693dea123f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_get_or_alloc_map </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *&#160;</td>
          <td class="paramname"><em>mapin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>vecin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keystring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper routine for get_or_allocXXXX() methods. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The newly-allocated or existing property id. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5561782353d3eac48f5a4008c86f6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_index_insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a method that most people should not use. It's used internally to keep the index up to date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The index property-id that needs to be updated.</td></tr>
    <tr><td class="paramname">pval</td><td>The property value to be inserted to the index.</td></tr>
    <tr><td class="paramname">vid</td><td>The vertex represented by that property in the index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ae82fb0bb5ac98aff8419210aa6fea342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_load_keys </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *&#160;</td>
          <td class="paramname"><em>vvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>revmap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility routine for reloading mappings between property-id's and property-name's. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="a7e0dc7f5d775a3d646e1f792085db888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_load_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility routine for reloading mappings between property-id's and property-name's. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ae3bb06021df4fbaa11e9eb89faca6eb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_save_keys </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; *&#160;</td>
          <td class="paramname"><em>vvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility routine for persisting mappings between property-id's and property-name's. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="a37bb69f593d95e73eb81d696f8c30a44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::_save_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility routine for persisting mappings between property-id's and property-name's. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="a505558098acbbf58f9c6e633b14e53d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vtarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a464ba627b686485b1de1236252823aa3">edge_property</a>&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge to the graph. </p>
<p>Note: please only use this method if you need to understand the underlying property implementation. Otherwise, please use the method of the same name that does not have a property parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source vertex of the edge. </td></tr>
    <tr><td class="paramname">vtarget</td><td>The target vertex of the edge. </td></tr>
    <tr><td class="paramname">ep</td><td>The property assoicated with the new edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>edged_type The eid of the new edge </dd></dl>

</div>
</div>
<a class="anchor" id="aad5968912df055d6e20af931056f0418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vtarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an edge to the graph.</p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source vertex of the edge. </td></tr>
    <tr><td class="paramname">vtarget</td><td>The target vertex of the edge. </td></tr>
    <tr><td class="paramname">lid</td><td>The label associated with the new edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edged_type The eid of the new edge </dd></dl>

</div>
</div>
<a class="anchor" id="aa52281f7c722d7ea91ae72c60790b30b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vtarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an edge to the graph.</p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source vertex of the edge. </td></tr>
    <tr><td class="paramname">vtarget</td><td>The target vertex of the edge. </td></tr>
    <tr><td class="paramname">lable</td><td>The label string associated with the new edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edged_type The eid of the new edge </dd></dl>

</div>
</div>
<a class="anchor" id="a63b8aa1b62befe5ba8aa661206f12a3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_edge_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vtarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source vertex of the edge. </td></tr>
    <tr><td class="paramname">vtarget</td><td>The target vertex of the edge. </td></tr>
    <tr><td class="paramname">lid</td><td>The label identifier associated with the new edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>edged_type The eid of the new edge </dd></dl>

</div>
</div>
<a class="anchor" id="a8dfcc846081131827b83140660126416"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_edge_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vtarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source vertex of the edge. </td></tr>
    <tr><td class="paramname">vtarget</td><td>The target vertex of the edge. </td></tr>
    <tr><td class="paramname">label</td><td>The label string associated with the new edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>edged_type The eid of the new edge </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2905ea6148bea170d916bececcecfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_index </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_multi</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method creates an index on the specified property and property value. </p>
<p>The caller should specify if it's possible that several vertices will have the same property value. It is safe to always specify that this is the case, but the code might be slightly slower than it needs to be. If the caller specifies that it's not the case, but then the graph does end up having more than one vertex with a given property value, the implementation will not notice this, but the index will not behave quite the way expected.</p>
<p>If the index already exists, this method does nothing. If it exists, but the is_multi is different than the existing index's is_multi value, still nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td>the vertex property that should be indexed </td></tr>
    <tr><td class="paramname">is_multi</td><td>true if a given value might appear on the property of several vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="abf6ef51763deb6d1c487e15ee6594a4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4d529729143c23ef9bb7a805ff0ded88">vertex_property</a> &amp;&#160;</td>
          <td class="paramname"><em>vp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex to the graph. </p>
<p>Note: please only use this method if you need to understand the underlying property implementation. Otherwise, please use the parameter-less method of the same name.</p>
<p>Note: this class probably doesn't index the values provided. If that is needed, please test to confirm that another method should be used or the caller should arrange indexing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vp</td><td>The vertex property of the new vertex begin added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertexd_type The vertex id of the new vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a98e32530fb68e5653240883dd0cca486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vclassid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex to the graph. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014) <pre class="fragment">#param vclassid The vclass associated with the new vertex
added. 
</pre></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertexd_type the vid of the new vertex </dd></dl>

</div>
</div>
<a class="anchor" id="a920dd12971badb795439a45e2d10cba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_vertex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vclassid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>exid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exidlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a vertex </p>
<p>This method does assume a vertex with that exid is not yet in the graph. If the caller is uncertain, it should check.</p>
<dl class="section author"><dt>Author</dt><dd>ccjason (8/28/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertexd_type </dd></dl>

</div>
</div>
<a class="anchor" id="a746e0fcade63422e52fb3606aba18600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::add_vertexxxx </td>
          <td>(</td>
          <td class="paramtype">property_value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex to the graph. </p>
<p>Adds a vertex to the graph with a specified property value The property value is associated with the external id. </p>
<pre class="fragment">Design: if you're using this method, check out if one of the 
other methods is faster.   External id's are stored as 
lstrings, so converting to std::strings to call this method 
might be a waste of cycles. 

If you do need this method, please correct the name to be 
more reasonable. 
</pre><dl class="section author"><dt>Author</dt><dd>ccjason (1/7/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertexd_type the vid of the new vertex </dd></dl>

</div>
</div>
<a class="anchor" id="a6da6c1d5dc0ad1870cc1903c538e01bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::delete_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes specified vertex and adjacent edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ab496b5277cc15f9dff150c0e71732d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::find_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows the caller to find all the vertices that have the given value on the given property. This version will not die if the index doesn't exist. Instead it will slowly generate the response after printing a warning message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>the property of interest</td></tr>
    <tr><td class="paramname">pval</td><td>the property value that must match</td></tr>
    <tr><td class="paramname">vids</td><td>a reference to a vector of vids that will be updated with the vids of matching vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is found, false otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ae5c2ce19f6109a3f6352b21465e64e6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td>
          <td class="paramname"><em>eid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first edge for a given vertex with a given edge id. </p>
<p>This routine returns an iterator for a edge with the given property id. This method should be fairly fast, but not as fast as already having an iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex for which the edges are considered. </td></tr>
    <tr><td class="paramname">eid</td><td>The edge id being searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertex_iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a78e66d72ed1a3aff69375e4a0ea61396"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first vertex with a given vertex id. </p>
<p>This routine returns an iterator for a vertex with the given property id. This method should be fairly fast, but not as fast as already having an iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex id being searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertex_iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6365310ff63de7a9c732ef354a9f76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first vertex with a given property value. </p>
<p>This routine returns an iterator for a vertex with the given property value. If you really want multiple vertices with the same value, then you probably should refactor the graph to have a single vertex representing that value and have other vertices reference it.</p>
<p>At this date (2014/01/06) this method is not implemented. We'll implement it when we add indexing support. Until then the caller should perhaps implement this themselves and include appropriate caching support to that implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td>the property name being searched </td></tr>
    <tr><td class="paramname">pval</td><td>the property value for specified property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>vertex_iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a57b9d9c704224b683e8b73ca36be1bd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_edge_property_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number or propertynames found edge in the graph. The caller can follow this up by calling get_property_name() from 0 .. ((returned value-1)) Values 0, 1... are reserved pseudo-properties, so the caller might chose to skip these and start with the CSVP_PROPERTIES_FIRST_NON_PSEUDO_PROPERTY property. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (9/15/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a class="anchor" id="a824e7c28d996539890b1a67b45871103"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_edge_property_name </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>propid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified edge property-id to it's property name. </p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The edge property id for which the name is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The property name </dd></dl>

</div>
</div>
<a class="anchor" id="ae8f00c7a993162b7fc47938958bdd985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_epropertyid </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified edge property-name to it's property-id. </p>
<p>This method can be valuable because operations on property id's are faster than operations on property names.</p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td><a class="el" href="classibmppl_1_1Edge.html" title="Generic implementation of graph edge templated by Property type. ">Edge</a> property name for which id is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The property name </dd></dl>

</div>
</div>
<a class="anchor" id="a9073965031afdb930a81ae1a97aa0c0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_label_string </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>labelid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified label-id it's label string. </p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelid</td><td>The label-id for which the string is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/10/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The label string </dd></dl>

</div>
</div>
<a class="anchor" id="a93af8b201084c791c37dd18ffda4d12f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_labelid </td>
          <td>(</td>
          <td class="paramtype">const label_string_type &amp;&#160;</td>
          <td class="paramname"><em>labelstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified label name to it's label-id. </p>
<p>This method maps the specified label-string to a label-id. If the label does not exist, it returs false, otherwise sets the parameter to the label-id. Label-id's can be valuable because operations on label id's are faster than operations on label strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelstr</td><td>The label string requested. </td></tr>
    <tr><td class="paramname">retval</td><td>The label id, if the label string exists in the mapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/10/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the mapping existed, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dec84cb6d7f6945e59e0c2c4976ca54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_labelid </td>
          <td>(</td>
          <td class="paramtype">const label_string_type &amp;&#160;</td>
          <td class="paramname"><em>labelstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified label string to it's label-id. </p>
<p>This method can be valuable because operations on labelid's are faster than operations on label strings.</p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelstr</td><td>The label for which an id is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/10/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The labelid </dd></dl>

</div>
</div>
<a class="anchor" id="ac27c35a232c23c1fd9fde1d44280cacf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_or_allocate_epropertyid </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified edge property-name to it's property-id. </p>
<p>This method maps the specified edge property-name to a vertex property-id. If that mapping doesn't exist, it creates one.</p>
<p>Property-id's can be valuable because operations on property id's are faster than operations on property names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td>The name of the edge property requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The property name </dd></dl>

</div>
</div>
<a class="anchor" id="a8bb515737948cd963db684c951a1e907"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_or_allocate_labelid </td>
          <td>(</td>
          <td class="paramtype">const label_string_type &amp;&#160;</td>
          <td class="paramname"><em>labelstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified label name to it's label-id. </p>
<p>This method maps the specified label-string to a label-id. If that mapping doesn't exist, it creates one.</p>
<p>Label-id's can be valuable because operations on label id's are faster than operations on label strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelstr</td><td>The label string requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/10/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The label string </dd></dl>

</div>
</div>
<a class="anchor" id="a31ae1880dc0ea90b5d57fe615675f724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_or_allocate_vpropertyid </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified vertex property-name to it's property-id. </p>
<p>This method maps the specified vertex property-name to a vertex property-id. If that mapping doesn't exist, it creates one.</p>
<p>Property-id's can be valuable because operations on property id's are faster than operations on property names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td>The name of the property requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The property name </dd></dl>

</div>
</div>
<a class="anchor" id="a6614a7c13e9a5387cfcd398f1c0e5d0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_vertex_property_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number or propertynames found vertices in the graph. The caller can follow this up by calling get_property_name() from 0 .. ((returned value-1)) Values 0, 1... are reserved pseudo-properties, so the caller might chose to skip these and start with the CSVP_PROPERTIES_FIRST_NON_PSEUDO_PROPERTY property. </p>
<dl class="section author"><dt>Author</dt><dd>ccjason (9/15/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a class="anchor" id="ac8499115382af4c0f52601231207e68e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_vertex_property_name </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>propid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified vertex property-id to it's property value. </p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The vertex property id for which the name is being requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>string The property name </dd></dl>

</div>
</div>
<a class="anchor" id="a5150345ed560ac93a0a7431d7ce2b33c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_vpropertyid </td>
          <td>(</td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a specified vertex property-name to it's property-id. </p>
<p>This method can be valuable because operations on property id's are faster than operations on property names.</p>
<p>If the mapping doesn't exist, it will (currently) throw an out of range exception. That might change in a future version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pname</td><td>The vertex property name for which the id is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The labelid </dd></dl>

</div>
</div>
<a class="anchor" id="a544b5621faf5a29ebd355c256a3cdd96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">property_value_type <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_vsubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specified property for the specified vertex. </p>
<p>This method returns the specified property for the specified vertex. The returned value is in string form. If the value itself is not a string value, the returned value is converted to string form before being returned.</p>
<p>Note: update docs to indicate what happens if the property doesn't exist on the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex for which the property is being queried. </td></tr>
    <tr><td class="paramname">pname</td><td>The name of the property being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>property_value_type </dd></dl>

</div>
</div>
<a class="anchor" id="a3ddfe41c9c823e879f3e653918e86e7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">property_value_type <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::get_vsubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>propid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the specified property for the specified vertex.</p>
<p>This method returns the specified property for the specified vertex. The returned value is in string form. If the value itself is not a string value, the returned value is converted to string form before being returned.</p>
<p>Note: update docs to indicate what happens if the property doesn't exist on the element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex for which the property is being queried. </td></tr>
    <tr><td class="paramname">propid</td><td>The property id being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>property_value_type </dd></dl>

</div>
</div>
<a class="anchor" id="a79f6da301fd8da8c3cf535311d07fa74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::index_erase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a method that most people should not use. It's used internally to keep the index up to date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The index property-id that needs to be updated.</td></tr>
    <tr><td class="paramname">pval</td><td>The property value to be erased to the index.</td></tr>
    <tr><td class="paramname">vid</td><td>The vertex represented by that property in the index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ac0840ee6fa0aeced4b920420dbc409f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::index_erasexx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a method that most people should not use. It's used internally to keep the index up to date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The index property-id that needs to be updated.</td></tr>
    <tr><td class="paramname">pval</td><td>The property value to be erased to the index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ac82e7266a0febc54e471ea2e43957f4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::index_find </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &amp;&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows the caller to find the vid of a vertex that has the given value on the given property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>the property of interest</td></tr>
    <tr><td class="paramname">pval</td><td>the property value that must match</td></tr>
    <tr><td class="paramname">vid</td><td>a reference to a vid that will be updated with the vid of a matching vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is found, false otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a5edf7328f3660d75146b780bb02f2be2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::index_find_all </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>pval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows the caller to find all the vertices that have the given value on the given property. Warning: it will crash if there is no index. Check for that using the "available" method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>the property of interest</td></tr>
    <tr><td class="paramname">pval</td><td>the property value that must match</td></tr>
    <tr><td class="paramname">vids</td><td>a reference to a vector of vids that will be updated with the vids of matching vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is found, false otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="acb8eac708a7927d635ce1a442f4f6413"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::set_esubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td>
          <td class="paramname"><em>eid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a property to an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eid</td><td>The edge to add the property to </td></tr>
    <tr><td class="paramname">pname</td><td>The property name to be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The property value to be set for the named property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="aaffd27bb8ad2e23eb44e90b6b1e6b687"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::set_esubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a723782cd96926999cc235a8acf8f1654">edged_type</a>&#160;</td>
          <td class="paramname"><em>eid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a property to an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eid</td><td>The edge to add the property to </td></tr>
    <tr><td class="paramname">pid</td><td>The property id to be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The property value to be set for the named property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="a495c689c7019abbfd21b7004edffc68e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::set_vsubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_name_type &amp;&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the specified property for the specified vertex to the specified string value. </p>
<p>This method set the specified property for the specified vertex to the specified string value. If you'd like to set it to a non-string value, see the other similarly named methods of the vertex and edge classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex to add the property to </td></tr>
    <tr><td class="paramname">pname</td><td>The property name to add to the specified vertex. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be set for the specified property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b54de7b66b679bf4705d0926f91e96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::set_vsubproperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4243ae01a238e356583fe77a2fbfa857">vertexd_type</a>&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>propid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const property_value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the specified property for the specified vertex to the specified string value. </p>
<p>This method set the specified property for the specified vertex to the specified string value. If you'd like to set it to a non-string value, see the other similarly named methods of the vertex and edge classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vid</td><td>The vertex to add the property to </td></tr>
    <tr><td class="paramname">propid</td><td>The property idetifier to add to the specified vertex. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be set for the specified property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (1/6/2014) </dd></dl>

</div>
</div>
<a class="anchor" id="a36e2c66da8b31db8b0b9fed2d755ff7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::vert_index_available </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>propid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method indicates if the named index exists. Currently the index name is the name of the vertex property that would be indexed. At the moment this class does not support edge properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The property id queried for indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>ccjason (3/4/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="adf9814917066d9a10b0bf8ad9c8d9c2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;STORAGE_TYPE ST&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic</a>&lt; ST &gt;::vert_index_available_we </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>propid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is like <a class="el" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a36e2c66da8b31db8b0b9fed2d755ff7b" title="This method indicates if the named index exists. Currently the index name is the name of the vertex p...">vert_index_available()</a> but it will throw an out_of_range exception if the propid is beyond the highest index we're supporting. This will help the calling code to enumerate indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propid</td><td>The property id queried for indexing.</td></tr>
  </table>
  </dd>
</dl>
<p>todo: if the number of propid's allocated is often high, this polling approach will be inefficient and we'll need to replace this method.</p>
<dl class="section author"><dt>Author</dt><dd>ccjason (7/19/2014)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/yxia/Work/ibmppl.gsa/datastructure/graph/ibm_multiproperty_graph.hpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
