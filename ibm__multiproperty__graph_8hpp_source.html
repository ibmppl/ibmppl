<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>IBM SYSTEMG RUNTIME: PPL: /home/yxia/Work/ibmppl.gsa/datastructure/graph/ibm_multiproperty_graph.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">IBM SYSTEMG RUNTIME: PPL
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">Parallel Programming Library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/yxia/Work/ibmppl.gsa/datastructure/graph/ibm_multiproperty_graph.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef _IBM_MULTI_PROPERTY_GRAPH_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define _IBM_MULTI_PROPERY_GRAPH_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;ibm_graph.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;dbstore/graph_disk_storage.h&quot;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">//for index support</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;datastructure/index/index.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;datastructure/common/filesystem.h&quot;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;tabular_multiproperty.hpp&quot;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;include/checkconsistency.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#if CHECK_CONSISTENCY</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">   #define CHKCONSIST_GRAPH1()  if (gp2!=_graph_ptr) { printf(&quot;inconsistency at ln %d on 0x%lx\n&quot;, __LINE__, (unsigned long)this); throw 505;  }</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">   #define CHKCONSIST_GRAPH1()</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#ifndef MPGLOGDEBUG</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#define MPGLOGDEBUG 0</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="keyword">namespace </span>ibmppl{ 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00036"></a>00036 <span class="comment">//#define CACHING1_SUPPORT 0</span>
<a name="l00037"></a>00037 <span class="comment">//#undef CACHING1_SUPPORT</span>
<a name="l00038"></a>00038 
<a name="l00043"></a>00043 <span class="keyword">template</span> &lt;<span class="keyword">class</span> GraphElement, <span class="keyword">class</span> BaseIterator, <span class="keyword">class</span> Graph, <span class="keyword">class</span> IdType&gt;
<a name="l00044"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">00044</a> <span class="keyword">class </span><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a> <span class="comment">/*: public BaseIterator*/</span><span class="comment">/*commented this out because we prefer not to accidentally pick up the parent methods and would prefer to have unimplemented methods flagged so that we can check them over to insure that they are implemnted correctly.*/</span> {
<a name="l00045"></a>00045     <span class="keyword">typedef</span> BaseIterator        base_type;
<a name="l00046"></a>00046     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">Graph</a>               <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>;
<a name="l00047"></a>00047 <span class="keyword">public</span>:
<a name="l00048"></a>00048   <span class="keyword">typedef</span> IdType                                    elementd_type;
<a name="l00049"></a>00049   <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphElement::property_type      property_type;
<a name="l00050"></a>00050   <span class="keyword">typedef</span> std::string property_name_type;
<a name="l00051"></a>00051   <span class="keyword">typedef</span> std::string property_value_type;
<a name="l00052"></a>00052   <span class="keyword">typedef</span> std::string label_string_type;
<a name="l00053"></a>00053                 
<a name="l00054"></a>00054   <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>() : _graph_ptr(NULL)
<a name="l00055"></a>00055       <span class="preprocessor">#if CHECK_CONSISTENCY</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>          , gp2(NULL) 
<a name="l00057"></a>00057       <span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>          {}
<a name="l00059"></a>00059   <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>(base_type it, <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>* g):  _iter(it),_graph_ptr(g)
<a name="l00060"></a>00060       <span class="preprocessor">#if CHECK_CONSISTENCY</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>          , gp2(g) 
<a name="l00062"></a>00062       <span class="preprocessor">#endif</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>  { }
<a name="l00064"></a>00064   
<a name="l00065"></a>00065   ~<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>() {
<a name="l00066"></a>00066       CHKCONSIST_GRAPH1();
<a name="l00067"></a>00067   }
<a name="l00068"></a>00068 
<a name="l00077"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">00077</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">check_consistency</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * filename, <span class="keywordtype">int</span> linenum){ 
<a name="l00078"></a>00078     <span class="comment">//printf(&quot;mpg055 on 0x%lx  from (%s:%d)\n&quot;, (unsigned long)this,filename,linenum); </span>
<a name="l00079"></a>00079     CHKCONSIST_ASSERT4(gp2 == _graph_ptr, <span class="stringliteral">&quot;corrupted iterator memory&quot;</span>, filename, linenum);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="comment">//This operator is fine and it comforms to C++ standard interface of</span>
<a name="l00084"></a>00084   <span class="comment">//an iterator; The C++ components of the framework will use this</span>
<a name="l00085"></a>00085   <span class="comment">//interface</span>
<a name="l00086"></a>00086   GraphElement&amp; operator*() {
<a name="l00087"></a>00087     <span class="keywordflow">return</span> *_iter;
<a name="l00088"></a>00088   }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   imp_graphelement_iterator* operator-&gt;() {
<a name="l00091"></a>00091     <span class="keywordflow">return</span> <span class="keyword">this</span>; 
<a name="l00092"></a>00092   }
<a name="l00093"></a>00093 
<a name="l00099"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a88f0f0fe6886dbf37f5a8fd25897d4d0">00099</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a88f0f0fe6886dbf37f5a8fd25897d4d0">operator++</a>(<span class="keywordtype">int</span> xx) { <span class="comment">// postfix ++</span>
<a name="l00100"></a>00100       _iter++;
<a name="l00101"></a>00101   }
<a name="l00107"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aec1d351ef116babe488e3210e8234a22">00107</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aec1d351ef116babe488e3210e8234a22">operator++</a>() { <span class="comment">// prefix ++</span>
<a name="l00108"></a>00108       _iter++;
<a name="l00109"></a>00109   }
<a name="l00110"></a>00110 
<a name="l00118"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#abb091b0524935beeead462bd494891a1">00118</a>   <span class="keywordtype">bool</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#abb091b0524935beeead462bd494891a1">operator==</a>(<span class="keyword">const</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>&amp; other) {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> _iter == other._iter;
<a name="l00120"></a>00120   }
<a name="l00121"></a>00121   <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>&amp; other) {
<a name="l00122"></a>00122     <span class="keywordflow">return</span> _iter != other._iter;
<a name="l00123"></a>00123   }
<a name="l00124"></a>00124 
<a name="l00133"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a11c891b4a5b42ff9a3f711642b2b4f4d">00133</a>   <span class="keyword">const</span> property_type&amp; <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a11c891b4a5b42ff9a3f711642b2b4f4d">property</a>()<span class="keyword"> const</span>
<a name="l00134"></a>00134 <span class="keyword">  </span>{ <span class="comment">// todo: don&#39;t like this method because we&#39;re exposing an underlying structure without our controlled interface</span>
<a name="l00135"></a>00135           property_type&amp; retval = _iter-&gt;property();
<a name="l00136"></a>00136           retval-&gt;check_consistency(__FILE__,__LINE__);
<a name="l00137"></a>00137           <span class="keywordflow">return</span> retval;
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139 
<a name="l00149"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a979709c72e3dedf0a5a584bd545272b1">00149</a>   <span class="keyword">const</span> elementd_type <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a979709c72e3dedf0a5a584bd545272b1">id</a>()<span class="keyword"> const</span>
<a name="l00150"></a>00150 <span class="keyword">  </span>{
<a name="l00151"></a>00151     <span class="keywordflow">return</span> _iter-&gt;id();
<a name="l00152"></a>00152   }
<a name="l00153"></a>00153 
<a name="l00162"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a9ad1ad9b3e0e45bb1398f0ad1c3180e2">00162</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a9ad1ad9b3e0e45bb1398f0ad1c3180e2">set_property</a>(property_type&amp; new_vp) 
<a name="l00163"></a>00163   { 
<a name="l00164"></a>00164       <span class="keywordflow">throw</span> 55; <span class="comment">// not valid to call from external code.  The concept doesn&#39;t work well.   And we don&#39;t want this called, overwriting the values we&#39;re managing.</span>
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00179"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ae85c54eaa891e2b0580458e8ff94d098">00179</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ae85c54eaa891e2b0580458e8ff94d098">get_first_subproperty_id</a>(){
<a name="l00180"></a>00180       <span class="comment">// todo: later update this to insure that it&#39;s never set twice.</span>
<a name="l00181"></a>00181 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>        property_type * prop = _get_cached_property();
<a name="l00183"></a>00183         <span class="keywordflow">if</span> (prop) {
<a name="l00184"></a>00184           <span class="keywordflow">return</span> prop-&gt;get_first_subproperty_id();
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 <span class="preprocessor">      #endif</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_first_subproperty_id();
<a name="l00188"></a>00188   }
<a name="l00200"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa0450c680267a87676e2d9836d9e5239">00200</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa0450c680267a87676e2d9836d9e5239">get_next_subproperty_id</a>(<span class="keywordtype">size_t</span> propid){
<a name="l00201"></a>00201       <span class="comment">// todo: later update this to insure that it&#39;s never set twice.</span>
<a name="l00202"></a>00202 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>        property_type * prop = _get_cached_property();
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (prop) {
<a name="l00205"></a>00205             <span class="keywordflow">return</span> prop-&gt;get_next_subproperty_id(propid);
<a name="l00206"></a>00206         }
<a name="l00207"></a>00207 <span class="preprocessor">      #endif</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_next_subproperty_id(propid);
<a name="l00209"></a>00209   }
<a name="l00210"></a>00210 
<a name="l00227"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aab4862bdf0aaae8122ea5e754a02131c">00227</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aab4862bdf0aaae8122ea5e754a02131c">set_externalid</a>(property_value_type value){
<a name="l00228"></a>00228       <span class="comment">// todo: later update this to insure that it&#39;s never set twice.</span>
<a name="l00229"></a>00229       <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">set_subproperty</a>(CSVP_PROPERTIES_EXID,value);
<a name="l00230"></a>00230   }
<a name="l00231"></a>00231 
<a name="l00242"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a09fc22e2abc30262c72a32beff68ee3d">00242</a>   std::string <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a09fc22e2abc30262c72a32beff68ee3d">get_externalid</a>() {  <span class="comment">// note: implementations that don&#39;t have to support this mapping will probably be more space efficient</span>
<a name="l00243"></a>00243     <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(CSVP_PROPERTIES_EXID);
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00258"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a493ea1713fb907a9cb423b25d684920f">00258</a>   std::string <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a493ea1713fb907a9cb423b25d684920f">get_label</a>() {
<a name="l00259"></a>00259       img_labelid_type labelid = <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a232172583d37b256043b091d4491f19b">get_labelid</a>();
<a name="l00260"></a>00260       <span class="keywordflow">if</span> (CSVP_UNSET_LABELID == labelid) <span class="keywordflow">throw</span> 506;
<a name="l00261"></a>00261       std::string retval = this-&gt;_graph_ptr-&gt;get_label_string(labelid);
<a name="l00262"></a>00262       <span class="keywordflow">return</span> retval;
<a name="l00263"></a>00263   }
<a name="l00264"></a>00264 
<a name="l00276"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a232172583d37b256043b091d4491f19b">00276</a>   img_labelid_type <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a232172583d37b256043b091d4491f19b">get_labelid</a>() {
<a name="l00277"></a>00277       <span class="keywordflow">if</span> (!_isEdge) <span class="keywordflow">throw</span> 505; <span class="comment">// must be edge</span>
<a name="l00278"></a>00278 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00280"></a>00280           <span class="keywordflow">if</span> (prop) {
<a name="l00281"></a>00281               <span class="keywordflow">return</span> prop-&gt;get_labelid();
<a name="l00282"></a>00282           }
<a name="l00283"></a>00283 <span class="preprocessor">      #endif</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_labelid();
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286 
<a name="l00305"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ac55017cf669a1fc53bc5ca6d14cd70e5">00305</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ac55017cf669a1fc53bc5ca6d14cd70e5">set_label</a>( std::string label) {
<a name="l00306"></a>00306       <span class="keywordflow">if</span> (!_isEdge) <span class="keywordflow">throw</span> 505; <span class="comment">// must be edge</span>
<a name="l00307"></a>00307       img_labelid_type labelid = this-&gt;_graph_ptr-&gt;get_or_allocate_labelid(label);
<a name="l00308"></a>00308       <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a886ebce94ce65d1fd0ed334a8873ca2b">set_labelid</a>(labelid);
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310 
<a name="l00325"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a886ebce94ce65d1fd0ed334a8873ca2b">00325</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a886ebce94ce65d1fd0ed334a8873ca2b">set_labelid</a>( img_labelid_type labelid) {
<a name="l00326"></a>00326       <span class="keywordflow">if</span> (!_isEdge) <span class="keywordflow">throw</span> 505; <span class="comment">// must be edge</span>
<a name="l00327"></a>00327 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00329"></a>00329           <span class="keywordflow">if</span> (!prop) { <span class="comment">//printf(&quot;mpg113a\n&quot;);</span>
<a name="l00330"></a>00330               prop = <span class="keyword">new</span> property_type(_iter-&gt;property());  <span class="comment">//printf(&quot;mpg113b\n&quot;);</span>
<a name="l00331"></a>00331               _set_cached_property(prop);
<a name="l00332"></a>00332           }
<a name="l00333"></a>00333           prop-&gt;set_label(labelid);  <span class="comment">//printf(&quot;mpg114\n&quot;);</span>
<a name="l00334"></a>00334           <span class="comment">//_iter-&gt;set_property (p);  // persist later</span>
<a name="l00335"></a>00335 <span class="preprocessor">      #else</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>          property_type p = _iter-&gt;property();
<a name="l00337"></a>00337           p.set_label(labelid);
<a name="l00338"></a>00338           _iter-&gt;set_property (p);
<a name="l00339"></a>00339 <span class="preprocessor">      #endif</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>  }
<a name="l00341"></a>00341 
<a name="l00348"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">00348</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">set_subproperty</a>(<span class="keyword">const</span> property_name_type&amp; pname, property_value_type value){ 
<a name="l00349"></a>00349     <span class="keywordtype">size_t</span> propid = _get_or_allocate_propertyid(pname);
<a name="l00350"></a>00350     <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">set_subproperty</a>(propid, value);
<a name="l00351"></a>00351   } 
<a name="l00352"></a>00352   
<a name="l00353"></a>00353   <span class="comment">//GABI::</span>
<a name="l00354"></a>00354   <span class="comment">//room for optimizations here; right now I just did a simple wrapper</span>
<a name="l00355"></a>00355   <span class="comment">//around existing functionality provided by inDiskGraph</span>
<a name="l00365"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a520c6a351f6e0f75c21fd6754c5230ff">00365</a> <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a520c6a351f6e0f75c21fd6754c5230ff">set_subproperty</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> propid, property_value_type value){ 
<a name="l00366"></a>00366       <span class="comment">//printf(&quot;mpg111\n&quot;);    </span>
<a name="l00367"></a>00367 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00369"></a>00369           <span class="keywordflow">if</span> (!prop) { <span class="comment">//printf(&quot;mpg113a\n&quot;);</span>
<a name="l00370"></a>00370               prop = <span class="keyword">new</span> property_type(_iter-&gt;property());  <span class="comment">//printf(&quot;mpg113b\n&quot;);</span>
<a name="l00371"></a>00371               _set_cached_property(prop);
<a name="l00372"></a>00372           }
<a name="l00373"></a>00373           prop-&gt;set_subproperty(propid, value);  <span class="comment">//printf(&quot;mpg114\n&quot;);</span>
<a name="l00374"></a>00374           <span class="comment">//_iter-&gt;set_property (p);  // persist later</span>
<a name="l00375"></a>00375 <span class="preprocessor">      #else</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>            property_type p = _iter-&gt;property();
<a name="l00377"></a>00377 
<a name="l00378"></a>00378             <span class="comment">//GABI:: for index maintenance</span>
<a name="l00379"></a>00379             <span class="keywordflow">if</span> (_graph_ptr-&gt;index_available(propid)) { <span class="comment">//printf(&quot;mpg311\n&quot;);</span>
<a name="l00380"></a>00380                 <span class="keywordflow">try</span> {
<a name="l00381"></a>00381                     property_value_type old_val = p.get_subproperty (propid); <span class="comment">//printf(&quot;mpg313\n&quot;);</span>
<a name="l00382"></a>00382                     _graph_ptr-&gt;index_erase(propid,old_val,this-&gt;<span class="keywordtype">id</span>());
<a name="l00383"></a>00383                 } <span class="keywordflow">catch</span> (...) {
<a name="l00384"></a>00384                 };
<a name="l00385"></a>00385                 _graph_ptr-&gt;index_insert(propid,value,this-&gt;<span class="keywordtype">id</span>());
<a name="l00386"></a>00386             }<span class="comment">//printf(&quot;mpg318\n&quot;);</span>
<a name="l00387"></a>00387 
<a name="l00388"></a>00388             p.set_subproperty (propid, value);
<a name="l00389"></a>00389             _iter-&gt;set_property (p);
<a name="l00390"></a>00390 <span class="preprocessor">      #endif</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span>  }
<a name="l00392"></a>00392 
<a name="l00398"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ab96015fb02bb1450baf2bef86b3e4ae4">00398</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ab96015fb02bb1450baf2bef86b3e4ae4">set_subproperty</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> propid, <span class="keywordtype">int</span> ivalue){ 
<a name="l00399"></a>00399       <span class="comment">//printf(&quot;mpg111\n&quot;);    </span>
<a name="l00400"></a>00400 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00402"></a>00402           <span class="keywordflow">if</span> (!prop) { <span class="comment">//printf(&quot;mpg113a\n&quot;);</span>
<a name="l00403"></a>00403               prop = <span class="keyword">new</span> property_type(_iter-&gt;property());  <span class="comment">//printf(&quot;mpg113b\n&quot;);</span>
<a name="l00404"></a>00404               _set_cached_property(prop);
<a name="l00405"></a>00405           }
<a name="l00406"></a>00406           prop-&gt;set_subproperty(propid, ivalue);  <span class="comment">//printf(&quot;mpg114\n&quot;);</span>
<a name="l00407"></a>00407           <span class="comment">//_iter-&gt;set_property (p);  // persist later</span>
<a name="l00408"></a>00408 <span class="preprocessor">      #else</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>          property_type p = _iter-&gt;property();
<a name="l00410"></a>00410           p.set_subproperty (propid, ivalue);
<a name="l00411"></a>00411           _iter-&gt;set_property (p);
<a name="l00412"></a>00412 <span class="preprocessor">      #endif</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>  }
<a name="l00414"></a>00414 
<a name="l00420"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a72bed296e0734c768c55325ea4673574">00420</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a72bed296e0734c768c55325ea4673574">set_subproperty</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> propid, <span class="keywordtype">double</span> dvalue){ 
<a name="l00421"></a>00421       <span class="comment">//printf(&quot;mpg111\n&quot;);    </span>
<a name="l00422"></a>00422 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00424"></a>00424           <span class="keywordflow">if</span> (!prop) { <span class="comment">//printf(&quot;mpg113a\n&quot;);</span>
<a name="l00425"></a>00425               prop = <span class="keyword">new</span> property_type(_iter-&gt;property());  <span class="comment">//printf(&quot;mpg113b\n&quot;);</span>
<a name="l00426"></a>00426               _set_cached_property(prop);
<a name="l00427"></a>00427           }
<a name="l00428"></a>00428           prop-&gt;set_subproperty(propid, dvalue);  <span class="comment">//printf(&quot;mpg114\n&quot;);</span>
<a name="l00429"></a>00429           <span class="comment">//_iter-&gt;set_property (p);  // persist later</span>
<a name="l00430"></a>00430 <span class="preprocessor">      #else</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span>          property_type p = _iter-&gt;property();
<a name="l00432"></a>00432           p.set_subproperty (propid, dvalue);
<a name="l00433"></a>00433           _iter-&gt;set_property (p);
<a name="l00434"></a>00434 <span class="preprocessor">      #endif</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>  }
<a name="l00436"></a>00436 
<a name="l00449"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">00449</a>   property_value_type <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(<span class="keyword">const</span> property_name_type&amp; pname){  
<a name="l00450"></a>00450     <span class="comment">//printf(&quot;mpg 079\n&quot;);</span>
<a name="l00451"></a>00451     <span class="keywordtype">size_t</span> propid = _get_or_allocate_propertyid(pname);
<a name="l00452"></a>00452     <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(propid);
<a name="l00453"></a>00453   }
<a name="l00454"></a>00454 
<a name="l00469"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ae0691d53be3d4ff67b7b2305737c541d">00469</a>   <span class="keywordtype">int</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ae0691d53be3d4ff67b7b2305737c541d">get_subpropertytype</a>(<span class="keywordtype">size_t</span> propid){  CHKCONSIST_GRAPH1();
<a name="l00470"></a>00470 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00472"></a>00472           <span class="keywordflow">if</span> (prop) <span class="keywordflow">return</span> prop-&gt;get_subpropertytype(propid);
<a name="l00473"></a>00473 <span class="preprocessor">      #endif</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>          <span class="comment">//printf(&quot;mpg406\n&quot;);</span>
<a name="l00475"></a>00475           <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">check_consistency</a>(__FILE__,__LINE__);
<a name="l00476"></a>00476           <span class="comment">//printf(&quot;mpg408\n&quot;);</span>
<a name="l00477"></a>00477           <span class="keywordtype">int</span> retval = _iter-&gt;property().get_subpropertytype(propid);
<a name="l00478"></a>00478           <span class="comment">//printf(&quot;mpg410\n&quot;);</span>
<a name="l00479"></a>00479           <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">check_consistency</a>(__FILE__,__LINE__);
<a name="l00480"></a>00480           <span class="comment">//printf(&quot;mpg412\n&quot;);</span>
<a name="l00481"></a>00481       <span class="keywordflow">return</span> retval;
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483 
<a name="l00498"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a7ef46e21faae4f977bdc54cf446e309b">00498</a>   property_value_type <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a7ef46e21faae4f977bdc54cf446e309b">get_subproperty</a>(<span class="keywordtype">size_t</span> propid){ CHKCONSIST_GRAPH1();
<a name="l00499"></a>00499 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00501"></a>00501           <span class="keywordflow">if</span> (prop) <span class="keywordflow">return</span> prop-&gt;get_subproperty(propid);
<a name="l00502"></a>00502 <span class="preprocessor">      #endif</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_subproperty(propid);
<a name="l00504"></a>00504   }
<a name="l00505"></a>00505 
<a name="l00516"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#abc2da61525820eb9cd19e97a0ab69889">00516</a>   <span class="keywordtype">int</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#abc2da61525820eb9cd19e97a0ab69889">get_int_subproperty</a>(<span class="keywordtype">size_t</span> propid){
<a name="l00517"></a>00517 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00519"></a>00519           <span class="keywordflow">if</span> (prop) <span class="keywordflow">return</span> prop-&gt;get_int_subproperty(propid);
<a name="l00520"></a>00520 <span class="preprocessor">      #endif</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_int_subproperty(propid);
<a name="l00522"></a>00522   }
<a name="l00523"></a>00523 
<a name="l00534"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a3f34c04f145a2242fef1abb1dcf25eaf">00534</a>   <span class="keywordtype">double</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a3f34c04f145a2242fef1abb1dcf25eaf">get_double_subproperty</a>(<span class="keywordtype">size_t</span> propid){
<a name="l00535"></a>00535 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00537"></a>00537           <span class="keywordflow">if</span> (prop) <span class="keywordflow">return</span> prop-&gt;get_double_subproperty(propid);
<a name="l00538"></a>00538 <span class="preprocessor">      #endif</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_double_subproperty(propid);
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541 
<a name="l00549"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#af81fd7f918a94f72a47f87ce4fa18b38">00549</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#af81fd7f918a94f72a47f87ce4fa18b38">delete_subproperty</a>(<span class="keyword">const</span> property_name_type&amp; pname){  
<a name="l00550"></a>00550       <span class="keywordtype">size_t</span> propid;  CHKCONSIST_GRAPH1();
<a name="l00551"></a>00551       <span class="keywordflow">try</span> {
<a name="l00552"></a>00552         propid = _get_propertyid(pname);
<a name="l00553"></a>00553       } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> exc) {
<a name="l00554"></a>00554           <span class="keywordflow">if</span> (MP_NOT_FOUND == exc) {
<a name="l00555"></a>00555             <span class="comment">// do nothing.  It&#39;s okay that we don&#39;t even have a mapping yet.</span>
<a name="l00556"></a>00556             <span class="keywordflow">return</span>;
<a name="l00557"></a>00557           } <span class="keywordflow">else</span> {
<a name="l00558"></a>00558               <span class="keywordflow">throw</span> exc;
<a name="l00559"></a>00559           }
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561       <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#af81fd7f918a94f72a47f87ce4fa18b38">delete_subproperty</a>(propid);
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563 
<a name="l00569"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ac43f9513feb239fc245596c1bc852ac6">00569</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#ac43f9513feb239fc245596c1bc852ac6">delete_subproperty</a>(<span class="keywordtype">size_t</span> propid){
<a name="l00570"></a>00570 <span class="preprocessor">    #ifdef CACHING1_SUPPORT</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span>          property_type * prop = _get_cached_property();
<a name="l00572"></a>00572           <span class="keywordflow">if</span> (0==prop) {
<a name="l00573"></a>00573               prop = <span class="keyword">new</span> property_type(_iter-&gt;property());  <span class="comment">//printf(&quot;mpg113b\n&quot;);</span>
<a name="l00574"></a>00574               _set_cached_property(prop);
<a name="l00575"></a>00575           }
<a name="l00576"></a>00576           prop-&gt;delete_subproperty(propid);  <span class="comment">//printf(&quot;mpg114\n&quot;);</span>
<a name="l00577"></a>00577           <span class="comment">//_iter-&gt;set_property (p);  // persist later</span>
<a name="l00578"></a>00578 <span class="preprocessor">      #else</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span>          property_type p = _iter-&gt;property();
<a name="l00580"></a>00580           p.delete_subproperty (propid);
<a name="l00581"></a>00581           _iter-&gt;set_property (p);
<a name="l00582"></a>00582 <span class="preprocessor">      #endif</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span>  }
<a name="l00584"></a>00584 
<a name="l00592"></a><a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a483b5cfef2771c7ab20689da654f6ed3">00592</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a483b5cfef2771c7ab20689da654f6ed3">get_subproperty_count</a>(){
<a name="l00593"></a>00593 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>        property_type * prop = _get_cached_property();
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (prop) {
<a name="l00596"></a>00596             <span class="keywordflow">return</span> prop-&gt;get_subproperty_count();
<a name="l00597"></a>00597         }
<a name="l00598"></a>00598 <span class="preprocessor">      #endif</span>
<a name="l00599"></a>00599 <span class="preprocessor"></span>      <span class="keywordflow">return</span> _iter-&gt;property().get_subproperty_count();
<a name="l00600"></a>00600   }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 <span class="preprocessor">  #ifdef CACHING1_SUPPORT</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span>  <span class="comment">// FIXME: conceptually this should somehow be protected or private for friend, but it&#39;s used by the graph class.</span>
<a name="l00604"></a>00604   <span class="keywordtype">void</span> _commit_modified_subproperties(property_type&amp; newprop) 
<a name="l00605"></a>00605   {
<a name="l00606"></a>00606       <span class="comment">// our super class implements persistence with set_property, so for now we&#39;ll implement ours in terms of that.</span>
<a name="l00607"></a>00607         <span class="comment">//printf(&quot;mpg111 calling set_property to persist\n&quot;);</span>
<a name="l00608"></a>00608         _iter-&gt;set_property(newprop);
<a name="l00609"></a>00609   }
<a name="l00610"></a>00610 <span class="preprocessor">  #endif</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>
<a name="l00612"></a>00612 <span class="keyword">protected</span>:
<a name="l00613"></a>00613     <span class="keywordtype">bool</span> _isEdge;
<a name="l00614"></a>00614     <span class="keywordtype">long</span> vid_source; <span class="comment">// todo: do we need this?  Perhaps the baseedgeiterator already has this?</span>
<a name="l00615"></a>00615                              <span class="comment">// note: vid_source is unused for vertices.  Someone with more experience with C++ can move it in to the edge iterator</span>
<a name="l00616"></a>00616                              <span class="comment">// note: we want the type to be vertexd_type, but it&#39;s too hard to get that to compile right now.</span>
<a name="l00617"></a>00617 <span class="preprocessor">    #if CHECK_CONSISTENCY</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span>       <span class="keywordtype">char</span> eltype;
<a name="l00619"></a>00619 <span class="preprocessor">    #endif</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span>
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="preprocessor">    #ifdef CACHING1_SUPPORT</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span>    <span class="keywordtype">void</span> _set_cached_property(property_type * prop) {
<a name="l00624"></a>00624         <span class="keywordflow">if</span> (_isEdge) {
<a name="l00625"></a>00625           _graph_ptr-&gt;epropcache[vid_source][ _iter-&gt;id() ] = prop;
<a name="l00626"></a>00626         } <span class="keywordflow">else</span> {
<a name="l00627"></a>00627           _graph_ptr-&gt;vpropcache[ _iter-&gt;id() ] = prop;
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629     }
<a name="l00630"></a>00630     property_type * _get_cached_property() {
<a name="l00631"></a>00631         <span class="keywordflow">try</span> {
<a name="l00632"></a>00632             <span class="keywordflow">if</span> (_isEdge) {
<a name="l00633"></a>00633               property_type *prop = (property_type *)_graph_ptr-&gt;epropcache.at(vid_source).at( _iter-&gt;id() );
<a name="l00634"></a>00634               <span class="keywordflow">return</span> prop;
<a name="l00635"></a>00635             } <span class="keywordflow">else</span> {
<a name="l00636"></a>00636               property_type *prop = (property_type *)_graph_ptr-&gt;vpropcache.at( _iter-&gt;id() );
<a name="l00637"></a>00637               <span class="keywordflow">return</span> prop;
<a name="l00638"></a>00638             }
<a name="l00639"></a>00639         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; oor) {
<a name="l00640"></a>00640             <span class="keywordflow">return</span> 0;
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643 <span class="preprocessor">    #endif</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span>
<a name="l00645"></a>00645     <span class="keywordtype">size_t</span> _get_or_allocate_propertyid(<span class="keyword">const</span> property_name_type&amp; pname) {
<a name="l00646"></a>00646         <span class="comment">// todo: it would be great to make this method a abstract virtual method and implement it in the subclasses</span>
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (_isEdge) {
<a name="l00648"></a>00648             <span class="keywordtype">size_t</span> retval = this-&gt;_graph_ptr-&gt;get_or_allocate_epropertyid(pname);
<a name="l00649"></a>00649             <span class="keywordflow">return</span> retval;
<a name="l00650"></a>00650         } <span class="keywordflow">else</span> {
<a name="l00651"></a>00651             <span class="keywordtype">size_t</span> retval = this-&gt;_graph_ptr-&gt;get_or_allocate_vpropertyid(pname);
<a name="l00652"></a>00652             <span class="keywordflow">return</span> retval;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654     }
<a name="l00655"></a>00655     <span class="keywordtype">size_t</span> _get_propertyid(<span class="keyword">const</span> property_name_type&amp; pname) {
<a name="l00656"></a>00656         <span class="comment">// todo: it would be great to make this method a abstract virtual method and implement it in the subclasses</span>
<a name="l00657"></a>00657         <span class="keywordflow">if</span> (_isEdge) {
<a name="l00658"></a>00658             <span class="keywordtype">size_t</span> retval = this-&gt;_graph_ptr-&gt;get_epropertyid(pname);
<a name="l00659"></a>00659             <span class="keywordflow">return</span> retval;
<a name="l00660"></a>00660         } <span class="keywordflow">else</span> {  <span class="comment">//printf(&quot;mpg275 this=0x%lx   _graph_ptr=0x%lx  gp2=0x%lx \n&quot;, (unsigned long)this, (unsigned long)(this-&gt;_graph_ptr), (unsigned long)(this-&gt;gp2));  CHKCONSIST_GRAPH1();</span>
<a name="l00661"></a>00661             <span class="keywordtype">size_t</span> retval = this-&gt;_graph_ptr-&gt;get_vpropertyid(pname);
<a name="l00662"></a>00662             <span class="keywordflow">return</span> retval;
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664     }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666     base_type _iter;
<a name="l00667"></a>00667     graph_type* _graph_ptr;
<a name="l00668"></a>00668 <span class="preprocessor">    #if CHECK_CONSISTENCY</span>
<a name="l00669"></a>00669 <span class="preprocessor"></span>    graph_type* gp2;
<a name="l00670"></a>00670 <span class="preprocessor">    #endif</span>
<a name="l00671"></a>00671 <span class="preprocessor"></span>};
<a name="l00672"></a>00672 
<a name="l00683"></a>00683 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Edge, <span class="keyword">class</span> BaseEdgeIterator, <span class="keyword">class</span> Graph, <span class="keyword">class</span> IdType&gt;
<a name="l00684"></a><a class="code" href="classibmppl_1_1imp__edge__iterator.html">00684</a> <span class="keyword">class </span><a class="code" href="classibmppl_1_1imp__edge__iterator.html">imp_edge_iterator</a> : <span class="keyword">public</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>&lt;Edge,BaseEdgeIterator,Graph,IdType&gt; {
<a name="l00685"></a>00685     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">Graph</a>               <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>;
<a name="l00686"></a>00686     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">imp_graphelement_iterator&lt;Edge,BaseEdgeIterator,Graph,IdType&gt;</a> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>;
<a name="l00687"></a>00687     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#ae66dd6705430d44e662c96550640443a" title="Vertex descriptor. Unique vertex identifier.">Graph::vertexd_type</a>   vertexd_type;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="keyword">public</span>: 
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <a class="code" href="classibmppl_1_1imp__edge__iterator.html">imp_edge_iterator</a>():<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>(){
<a name="l00692"></a>00692 <span class="preprocessor">        #if CHECK_CONSISTENCY</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>            base_type::eltype = <span class="charliteral">&#39;e&#39;</span>;
<a name="l00694"></a>00694 <span class="preprocessor">        #endif</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span>    }  
<a name="l00703"></a><a class="code" href="classibmppl_1_1imp__edge__iterator.html#ace009c2dcee1a6ec8cee1018d24d6e55">00703</a>     <a class="code" href="classibmppl_1_1imp__edge__iterator.html#ace009c2dcee1a6ec8cee1018d24d6e55">imp_edge_iterator</a>(BaseEdgeIterator it, <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>* g, vertexd_type vidin):  <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>(it,g) { 
<a name="l00704"></a>00704         base_type::_isEdge = 1; 
<a name="l00705"></a>00705         base_type::vid_source = vidin;
<a name="l00706"></a>00706 <span class="preprocessor">        #if CHECK_CONSISTENCY</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span>            base_type::eltype = <span class="charliteral">&#39;e&#39;</span>;
<a name="l00708"></a>00708 <span class="preprocessor">        #endif</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span>    }
<a name="l00710"></a>00710     ~<a class="code" href="classibmppl_1_1imp__edge__iterator.html">imp_edge_iterator</a>() { <span class="comment">//printf(&quot;  mpg343 destructor\n&quot;);</span>
<a name="l00711"></a>00711       CHKCONSIST_ASSERT1(base_type::eltype == <span class="charliteral">&#39;e&#39;</span>);
<a name="l00712"></a>00712     }
<a name="l00713"></a><a class="code" href="classibmppl_1_1imp__edge__iterator.html#a8a7ad07bf950c9b9cc7aa36efa875192">00713</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__edge__iterator.html#a8a7ad07bf950c9b9cc7aa36efa875192">check_consistency</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * filename, <span class="keywordtype">int</span> linenum){ 
<a name="l00714"></a>00714         <span class="comment">//printf(&quot;mpg055 on 0x%lx  from (%s:%d)\n&quot;, (unsigned long)this,filename,linenum); </span>
<a name="l00715"></a>00715         CHKCONSIST_ASSERT4(base_type::eltype == <span class="charliteral">&#39;e&#39;</span>, <span class="stringliteral">&quot;incorrect iterator type&quot;</span>, filename, linenum);
<a name="l00716"></a>00716         <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">base_type::check_consistency</a>(filename, linenum);
<a name="l00717"></a>00717     }
<a name="l00718"></a>00718 
<a name="l00727"></a><a class="code" href="classibmppl_1_1imp__edge__iterator.html#a2c61b1e877e89d58ed3b890c03398bca">00727</a>     vertexd_type <a class="code" href="classibmppl_1_1imp__edge__iterator.html#a2c61b1e877e89d58ed3b890c03398bca">source</a>() {
<a name="l00728"></a>00728         vertexd_type retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__edge__iterator.html#a2c61b1e877e89d58ed3b890c03398bca">source</a>());
<a name="l00729"></a>00729         <span class="keywordflow">return</span> retval;
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 
<a name="l00740"></a><a class="code" href="classibmppl_1_1imp__edge__iterator.html#a9c66b9cc038bb10ba9e39a30a935ff0c">00740</a>     vertexd_type <a class="code" href="classibmppl_1_1imp__edge__iterator.html#a9c66b9cc038bb10ba9e39a30a935ff0c">target</a>() {
<a name="l00741"></a>00741         vertexd_type retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__edge__iterator.html#a9c66b9cc038bb10ba9e39a30a935ff0c">target</a>());
<a name="l00742"></a>00742         <span class="keywordflow">return</span> retval;
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 };
<a name="l00746"></a>00746 
<a name="l00758"></a>00758 <span class="keyword">template</span> &lt;<span class="keyword">class</span> GraphElement, <span class="keyword">class</span> BaseIterator, <span class="keyword">class</span> Graph&gt;
<a name="l00759"></a><a class="code" href="classibmppl_1_1imp__pred__iterator.html">00759</a> <span class="keyword">class </span><a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator</a> <span class="comment">/*: public BaseIterator*/</span><span class="comment">/*commented this out because we prefer not to accidentally pick up the parent methods and would prefer to have unimplemented methods flagged so that we can check them over to insure that they are implemnted correctly.*/</span> {
<a name="l00760"></a>00760     <span class="keyword">typedef</span> BaseIterator        base_type;
<a name="l00761"></a>00761     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">Graph</a>               <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>;
<a name="l00762"></a>00762     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#ae66dd6705430d44e662c96550640443a" title="Vertex descriptor. Unique vertex identifier.">Graph::vertexd_type</a>   vertexd_type;
<a name="l00763"></a>00763     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#ae90bc139ae269cf651cc3df4128aebab" title="Iterator type for traversing vertices.">Graph::vertex_iterator</a> vertex_iterator;
<a name="l00764"></a>00764 <span class="keyword">public</span>:
<a name="l00765"></a>00765   
<a name="l00766"></a>00766   <a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator</a>() : _graph_ptr(NULL) 
<a name="l00767"></a>00767   { <span class="comment">/*prop = 0;*/</span> 
<a name="l00768"></a>00768 <span class="preprocessor">    #if CHECK_CONSISTENCY</span>
<a name="l00769"></a>00769 <span class="preprocessor"></span>      gp2 = _graph_ptr;
<a name="l00770"></a>00770       eltype = <span class="charliteral">&#39;p&#39;</span>;
<a name="l00771"></a>00771 <span class="preprocessor">    #endif</span>
<a name="l00772"></a>00772 <span class="preprocessor"></span>  }
<a name="l00773"></a>00773   <a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator</a>(base_type it, <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>* g):  _iter(it),_graph_ptr(g)
<a name="l00774"></a>00774   { <span class="comment">/*prop = 0;*/</span> 
<a name="l00775"></a>00775 <span class="preprocessor">    #if CHECK_CONSISTENCY</span>
<a name="l00776"></a>00776 <span class="preprocessor"></span>      gp2 = _graph_ptr;
<a name="l00777"></a>00777       eltype = <span class="charliteral">&#39;p&#39;</span>;
<a name="l00778"></a>00778 <span class="preprocessor">    #endif</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>  }
<a name="l00780"></a>00780   ~<a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator</a>() {
<a name="l00781"></a>00781     CHKCONSIST_ASSERT1(eltype == <span class="charliteral">&#39;p&#39;</span>);
<a name="l00782"></a>00782   }
<a name="l00800"></a><a class="code" href="classibmppl_1_1imp__pred__iterator.html#aba3fde3d1ad87fba0c28a45632cd510e">00800</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__pred__iterator.html#aba3fde3d1ad87fba0c28a45632cd510e">check_consistency</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * filename, <span class="keywordtype">int</span> linenum){ 
<a name="l00801"></a>00801       <span class="comment">//printf(&quot;mpg055 on 0x%lx  from (%s:%d)\n&quot;, (unsigned long)this,filename,linenum); </span>
<a name="l00802"></a>00802       CHKCONSIST_ASSERT4(eltype == <span class="charliteral">&#39;p&#39;</span>, <span class="stringliteral">&quot;incorrect iterator type&quot;</span>, filename, linenum);
<a name="l00803"></a>00803       CHKCONSIST_ASSERT4(gp2==_graph_ptr,  <span class="stringliteral">&quot;corrupted pred iterator memory&quot;</span>, filename, linenum);
<a name="l00804"></a>00804   }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806   <span class="comment">//This operator is fine and it comforms to C++ standard interface of an iterator</span>
<a name="l00807"></a>00807   <span class="comment">//The C++ components of the framework will use this interface</span>
<a name="l00808"></a>00808   GraphElement&amp; operator*() {
<a name="l00809"></a>00809     <span class="keywordflow">return</span> *_iter;
<a name="l00810"></a>00810   }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   imp_pred_iterator* operator-&gt;() {
<a name="l00813"></a>00813     <span class="keywordflow">return</span> <span class="keyword">this</span>; 
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordtype">void</span> operator++(<span class="keywordtype">int</span> xx) { <span class="comment">// postfix ++</span>
<a name="l00817"></a>00817       _iter++;
<a name="l00818"></a>00818   }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   <span class="keywordtype">void</span> operator++() { <span class="comment">// prefix ++</span>
<a name="l00821"></a>00821       _iter++;
<a name="l00822"></a>00822   }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> imp_pred_iterator&amp; other) {
<a name="l00825"></a>00825     <span class="keywordflow">return</span> _iter == other._iter;
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> imp_pred_iterator&amp; other) {
<a name="l00829"></a>00829     <span class="keywordflow">return</span> _iter != other._iter;
<a name="l00830"></a>00830   }
<a name="l00831"></a>00831 
<a name="l00833"></a><a class="code" href="classibmppl_1_1imp__pred__iterator.html#a6d03ac039d85b555429a8bdbeec30dad">00833</a>   vertexd_type <a class="code" href="classibmppl_1_1imp__pred__iterator.html#a6d03ac039d85b555429a8bdbeec30dad" title="FIXME discuss these two new methods.">source_vid</a>() {
<a name="l00834"></a>00834       <span class="keywordflow">return</span> (*_iter);
<a name="l00835"></a>00835   }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   vertex_iterator source_vit() {
<a name="l00838"></a>00838       vertexd_type vid = *_iter;
<a name="l00839"></a>00839       vertex_iterator retval = _graph_ptr-&gt;find_vertex( vid );
<a name="l00840"></a>00840       <span class="keywordflow">return</span> retval;
<a name="l00841"></a>00841   }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843   base_type _iter;
<a name="l00844"></a>00844   graph_type* _graph_ptr;
<a name="l00845"></a>00845 <span class="preprocessor">  #if CHECK_CONSISTENCY</span>
<a name="l00846"></a>00846 <span class="preprocessor"></span>        graph_type* gp2;
<a name="l00847"></a>00847         <span class="keywordtype">char</span> eltype;
<a name="l00848"></a>00848 <span class="preprocessor">  #endif</span>
<a name="l00849"></a>00849 <span class="preprocessor"></span>};
<a name="l00850"></a>00850 
<a name="l00857"></a>00857 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Vertex, <span class="keyword">class</span> BaseIterator, <span class="keyword">class</span> Graph, <span class="keyword">class</span> IdType&gt;
<a name="l00858"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html">00858</a> <span class="keyword">class </span><a class="code" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator</a> : <span class="keyword">public</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html" title="Buffers all modifications to the properties until the user triggers the commit.">imp_graphelement_iterator</a>&lt;Vertex,BaseIterator,Graph,IdType&gt; {
<a name="l00859"></a>00859     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">Graph</a>               <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>;
<a name="l00860"></a>00860     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">imp_graphelement_iterator&lt;Vertex,BaseIterator,Graph,IdType&gt;</a> <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>;
<a name="l00861"></a>00861     <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::edge_type edge_type;
<a name="l00862"></a>00862     <span class="keyword">typedef</span> <span class="keyword">typename</span> graph_type::base_edge_iterator base_edge_iterator;
<a name="l00863"></a>00863     <span class="keyword">typedef</span> <span class="keyword">typename</span> BaseIterator::pred_iterator      base_pred_iterator;
<a name="l00864"></a>00864   
<a name="l00865"></a>00865 <span class="keyword">public</span>: 
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="keyword">typedef</span> <span class="keyword">typename</span> graph_type::edge_iterator      edge_iterator;
<a name="l00868"></a>00868     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator  &lt;edge_type,   base_pred_iterator,   Graph&gt;</a>   <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a>;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator</a>():<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>()
<a name="l00871"></a>00871     {
<a name="l00872"></a>00872 <span class="preprocessor">        #if CHECK_CONSISTENCY</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span>            base_type::eltype = <span class="charliteral">&#39;v&#39;</span>;
<a name="l00874"></a>00874 <span class="preprocessor">        #endif</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>    }
<a name="l00876"></a>00876     <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator</a>(BaseIterator it, <a class="code" href="classibmppl_1_1Graph.html" title="The main graph class to be instantiated by users.">graph_type</a>* g):  <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html">base_type</a>(it,g) 
<a name="l00877"></a>00877     { 
<a name="l00878"></a>00878         base_type::_isEdge = 0; 
<a name="l00879"></a>00879 <span class="preprocessor">        #if CHECK_CONSISTENCY</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>            base_type::eltype = <span class="charliteral">&#39;v&#39;</span>;
<a name="l00881"></a>00881 <span class="preprocessor">        #endif</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>    }
<a name="l00883"></a>00883     ~<a class="code" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator</a>() { <span class="comment">//printf(&quot;  mpg432 destructor\n&quot;);</span>
<a name="l00884"></a>00884       CHKCONSIST_ASSERT1(base_type::eltype == <span class="charliteral">&#39;v&#39;</span>);
<a name="l00885"></a>00885     }
<a name="l00903"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ae82900660854cb6f0dc042ff2a13595c">00903</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ae82900660854cb6f0dc042ff2a13595c">check_consistency</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * filename, <span class="keywordtype">int</span> linenum){ 
<a name="l00904"></a>00904         <span class="comment">//printf(&quot;mpg055 on 0x%lx  from (%s:%d)\n&quot;, (unsigned long)this,filename,linenum); </span>
<a name="l00905"></a>00905         CHKCONSIST_ASSERT4(base_type::eltype == <span class="charliteral">&#39;v&#39;</span>, <span class="stringliteral">&quot;incorrect iterator type&quot;</span>, filename, linenum);
<a name="l00906"></a>00906         <a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#aa7dd1de0b0bb26218710e6c5a234eb19">base_type::check_consistency</a>(filename, linenum);
<a name="l00907"></a>00907     }
<a name="l00916"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ac395f816a7cbe1b92e389507a0331766">00916</a>     edge_iterator <a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ac395f816a7cbe1b92e389507a0331766">edges_begin</a>() {
<a name="l00917"></a>00917         edge_iterator retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ac395f816a7cbe1b92e389507a0331766">edges_begin</a>(), base_type::_graph_ptr, base_type::_iter-&gt;<span class="keywordtype">id</span>());
<a name="l00918"></a>00918         <span class="keywordflow">return</span> retval;
<a name="l00919"></a>00919     }
<a name="l00930"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html#af63b27b0bd83604221d3f560a85d0eee">00930</a>     edge_iterator <a class="code" href="classibmppl_1_1imp__vertex__iterator.html#af63b27b0bd83604221d3f560a85d0eee">edges_end</a>() {
<a name="l00931"></a>00931         edge_iterator retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#af63b27b0bd83604221d3f560a85d0eee">edges_end</a>(), base_type::_graph_ptr, base_type::_iter-&gt;<span class="keywordtype">id</span>());
<a name="l00932"></a>00932         <span class="keywordflow">return</span> retval;
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934 
<a name="l00943"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ad9a69ed1c7dc1fcfa7ad33d4e4d19f8a">00943</a>     <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a> <a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ad9a69ed1c7dc1fcfa7ad33d4e4d19f8a">preds_begin</a>() {
<a name="l00944"></a>00944         <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a> retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ad9a69ed1c7dc1fcfa7ad33d4e4d19f8a">preds_begin</a>(), base_type::_graph_ptr);
<a name="l00945"></a>00945         <span class="keywordflow">return</span> retval;
<a name="l00946"></a>00946     }
<a name="l00947"></a>00947 
<a name="l00958"></a><a class="code" href="classibmppl_1_1imp__vertex__iterator.html#a26d36fab01c7901a7d72c6a19953b16b">00958</a>     <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a> <a class="code" href="classibmppl_1_1imp__vertex__iterator.html#a26d36fab01c7901a7d72c6a19953b16b">preds_end</a>() {
<a name="l00959"></a>00959         <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a> retval(base_type::_iter-&gt;<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#a26d36fab01c7901a7d72c6a19953b16b">preds_end</a>(), base_type::_graph_ptr);
<a name="l00960"></a>00960         <span class="keywordflow">return</span> retval;
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 };
<a name="l00964"></a>00964 
<a name="l00971"></a>00971 <span class="keyword">template</span> &lt;<span class="keyword">class</span> VProperty, <span class="keyword">class</span> EProperty, DIRECTNESS Directness&gt;
<a name="l00972"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">00972</a> <span class="keyword">class </span><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic</a> : <span class="keyword">public</span> inDiskGraph&lt;VProperty, EProperty, Directness&gt; {
<a name="l00973"></a>00973     <span class="keyword">typedef</span> inDiskGraph&lt;VProperty, EProperty, Directness&gt; base_type;
<a name="l00974"></a>00974     <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibm_multiproperty_graph_generic&lt;VProperty,EProperty,Directness&gt;</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">this_type</a>;
<a name="l00975"></a>00975  <span class="keyword">public</span>:
<a name="l00977"></a>00977   <span class="comment">//typedef Directness directness_type;</span>
<a name="l00978"></a>00978  
<a name="l00980"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311">00980</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#a9c588d2c567836ffe531a9d0daa769fa" title="Edge descriptor or unique edge identifier.">base_type::edged_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a>;
<a name="l00981"></a>00981   <span class="comment">//The vertex class; storage for property and edges</span>
<a name="l00982"></a>00982   <span class="keyword">typedef</span> <span class="keyword">typename</span> base_type::vertex_type vertex_type;
<a name="l00983"></a>00983   <span class="keyword">typedef</span> <span class="keyword">typename</span> base_type::edge_type edge_type;
<a name="l00985"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371">00985</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#ae66dd6705430d44e662c96550640443a" title="Vertex descriptor. Unique vertex identifier.">base_type::vertexd_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a>;
<a name="l00987"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719">00987</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#a4dcdfb59caa8ade3032f1b52700c9ba3" title="Property type associated with each vertex.">base_type::vertex_property</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a>;
<a name="l00989"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b">00989</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#a48cc44cbfea4e4d8fae8e895f69815fa" title="Property type associated with each edge.">base_type::edge_property</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b" title="Property type associated with each edge.">edge_property</a>;
<a name="l00991"></a>00991 
<a name="l00992"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a77786355f2838b90e3366b6f868e96a9">00992</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> base_type::edge_iterator <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a77786355f2838b90e3366b6f868e96a9" title="Iterator type for traversing vertices.">base_edge_iterator</a>;
<a name="l00993"></a>00993   <span class="keyword">typedef</span> <span class="keyword">typename</span> base_type::vertex_iterator base_vertex_iterator;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="keyword">typedef</span> <span class="keyword">typename</span> base_vertex_iterator::pred_iterator base_pred_iterator;
<a name="l00996"></a>00996 
<a name="l00997"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27">00997</a>   <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">imp_vertex_iterator&lt;vertex_type, base_vertex_iterator, this_type, vertexd_type&gt;</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a>;
<a name="l00998"></a>00998   <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__edge__iterator.html">imp_edge_iterator  &lt;edge_type,   base_edge_iterator,   this_type, edged_type&gt;</a>   <a class="code" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a>;
<a name="l00999"></a>00999   <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1imp__pred__iterator.html">imp_pred_iterator  &lt;edge_type,   base_pred_iterator,   this_type&gt;</a>   <a class="code" href="classibmppl_1_1imp__pred__iterator.html">pred_iterator</a>;
<a name="l01000"></a>01000 
<a name="l01002"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abcae073d6cbb2d35502d3ec36b2ba88f">01002</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classibmppl_1_1Graph.html#a4035bf7908a90f77f8bf385531ed1231">base_type::const_vertex_iterator</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abcae073d6cbb2d35502d3ec36b2ba88f" title="Const Iterator type for traversing edges. You won&#39;t be able to modify properties when using this iter...">const_vertex_iterator</a>;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="keyword">typedef</span> std::string property_name_type;
<a name="l01005"></a>01005   <span class="keyword">typedef</span> std::string property_value_type;
<a name="l01006"></a>01006   <span class="keyword">typedef</span> std::string label_string_type;
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keyword">private</span>:
<a name="l01010"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030">01010</a>   std::map&lt;std::string, size_t&gt; <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030" title="Maps a property name to a property id.">vpropname_to_id</a>;
<a name="l01012"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a459899780cffc4fa93ff32bdefa5046b">01012</a>   std::vector&lt;std::string&gt; <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a459899780cffc4fa93ff32bdefa5046b" title="Maps a property id to a property name(string)">id_to_vpropname</a>;
<a name="l01013"></a>01013 
<a name="l01015"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243">01015</a>   std::map&lt;std::string, size_t&gt; <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243" title="Similar as above for edges.">epropname_to_id</a>;
<a name="l01016"></a>01016   std::vector&lt;std::string&gt; id_to_epropname;
<a name="l01017"></a>01017 
<a name="l01019"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a312cc746c5f826ffb07ea5b667a08055">01019</a>   std::vector&lt;std::string&gt; <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a312cc746c5f826ffb07ea5b667a08055" title="Maps a label id to a label string.">id_to_label</a>;
<a name="l01021"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044">01021</a>   std::map&lt;std::string, size_t&gt; <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044" title="Maps a label string to a label id.">label_to_id</a>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   std::string store_name;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <span class="comment">//GABI:: index support</span>
<a name="l01026"></a>01026   <span class="comment">//we map from property value to vertex id</span>
<a name="l01027"></a>01027   <span class="keyword">typedef</span> index&lt;size_t&gt; index_type;
<a name="l01028"></a>01028   <span class="comment">//We are using an index proxy to store a pointer to the real index and </span>
<a name="l01029"></a>01029   <span class="comment">// thus when index_proxies are copied (e.g., inside std::vector) these</span>
<a name="l01030"></a>01030   <span class="comment">// are lightweight copies; </span>
<a name="l01031"></a>01031   <span class="keyword">typedef</span> std::vector&lt;index_type*&gt;::iterator index_iterator;
<a name="l01032"></a>01032   std::vector&lt;index_type*&gt; indices;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034         <span class="keyword">public</span>:  <span class="comment">// jlc: because I don&#39;t yet know how to do capitalize on friend declarations</span>
<a name="l01035"></a>01035 <span class="preprocessor">#ifdef CACHING1_SUPPORT</span>
<a name="l01036"></a>01036 <span class="preprocessor"></span>                <span class="comment">//Buffers for vertex and edge property changes </span>
<a name="l01037"></a>01037                 <span class="comment">// FIXME use vertexd_type and edged_type instead of long</span>
<a name="l01038"></a>01038                 std::map&lt;long,vertex_property *&gt; vpropcache;
<a name="l01039"></a>01039                 std::map&lt;long,std::map&lt;long,edge_property *&gt; &gt; epropcache;
<a name="l01052"></a>01052                 <span class="keywordtype">void</span> commit() {
<a name="l01053"></a>01053                         <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> bvitend = vertices_end();
<a name="l01054"></a>01054                         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::map&lt;<span class="keywordtype">long</span>,std::map&lt;long,edge_property *&gt; &gt;::iterator itV2 = epropcache.begin(); itV2 != epropcache.end(); ++itV2) {
<a name="l01055"></a>01055                                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid = (*itV2).first;
<a name="l01056"></a>01056                                 std::map&lt;long,edge_property *&gt; m2 = (*itV2).second;
<a name="l01057"></a>01057                                 <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(vid);
<a name="l01058"></a>01058                                 <span class="keywordflow">if</span> (bvitend!=bvit) {
<a name="l01059"></a>01059                                         <span class="keywordflow">for</span> (<a class="code" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> eit = bvit.<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#ac395f816a7cbe1b92e389507a0331766">edges_begin</a>(); eit != bvit.<a class="code" href="classibmppl_1_1imp__vertex__iterator.html#af63b27b0bd83604221d3f560a85d0eee">edges_end</a>(); ++eit) {
<a name="l01060"></a>01060                                                 <span class="keywordflow">try</span> {
<a name="l01061"></a>01061                                                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> eid = eit.id();
<a name="l01062"></a>01062                                                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b" title="Property type associated with each edge.">edge_property</a> * peprop = m2.at(eid);
<a name="l01063"></a>01063                                                         eit-&gt;_commit_modified_subproperties(*peprop);
<a name="l01064"></a>01064                                                         <span class="keyword">delete</span> peprop;  m2.erase(eid);
<a name="l01065"></a>01065                                                 } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; oor) {
<a name="l01066"></a>01066                                                         <span class="comment">// we don&#39;t have a change for that edge</span>
<a name="l01067"></a>01067                                                 }
<a name="l01068"></a>01068                                         }
<a name="l01069"></a>01069                                         { <span class="comment">// if there are any additional edge properties that were orphaned, free them</span>
<a name="l01070"></a>01070                                                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::map&lt;long,edge_property *&gt;::iterator m2iter = m2.begin(); m2iter!=m2.end(); ++m2iter) {
<a name="l01071"></a>01071                                                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b" title="Property type associated with each edge.">edge_property</a> * peprop = (*m2iter).second;
<a name="l01072"></a>01072                                                         <span class="keyword">delete</span> peprop;
<a name="l01073"></a>01073                                                 }
<a name="l01074"></a>01074                                         }
<a name="l01075"></a>01075                                         <span class="comment">// since we already have the iterator for this vertex, let&#39;s check if it has a modification</span>
<a name="l01076"></a>01076                                         <span class="keywordflow">try</span> {
<a name="l01077"></a>01077                                                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a> * pvprop = vpropcache.at(vid);
<a name="l01078"></a>01078                                                 bvit-&gt;_commit_modified_subproperties(*pvprop);
<a name="l01079"></a>01079                                                 vpropcache.erase(vid);  <span class="comment">// let&#39;s remove it from the mod list so that we don&#39;t persist it again when we iterate over vpropcache</span>
<a name="l01080"></a>01080                                                 <span class="keyword">delete</span> pvprop;
<a name="l01081"></a>01081                                         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; oor) {
<a name="l01082"></a>01082                                                 <span class="comment">// we don&#39;t have a change for that edge</span>
<a name="l01083"></a>01083                                         }
<a name="l01084"></a>01084                                 } <span class="keywordflow">else</span> {
<a name="l01085"></a>01085                                         <span class="comment">// the vertex was already removed from graph</span>
<a name="l01086"></a>01086                                         <span class="keywordflow">try</span> {
<a name="l01087"></a>01087                                                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a> * pvprop = vpropcache.at(vid);
<a name="l01088"></a>01088                                                 vpropcache.erase(vid);  <span class="comment">// let&#39;s remove it from the mod list so that we don&#39;t persist it again when we iterate over vpropcache</span>
<a name="l01089"></a>01089                                                 <span class="keyword">delete</span> pvprop;
<a name="l01090"></a>01090                                         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::out_of_range&amp; oor) {
<a name="l01091"></a>01091                                                 <span class="comment">// we don&#39;t have a change for that vertex, so there is nothing to free up</span>
<a name="l01092"></a>01092                                         }
<a name="l01093"></a>01093                                 }
<a name="l01094"></a>01094                         }
<a name="l01095"></a>01095                         <span class="keyword">typename</span> std::map&lt;long,vertex_property *&gt;::iterator itV = vpropcache.begin();
<a name="l01096"></a>01096                         <span class="keywordflow">for</span> (; itV != vpropcache.end(); ++itV) {
<a name="l01097"></a>01097                                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid = (*itV).first;
<a name="l01098"></a>01098                                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a> * pvprop = (*itV).second;
<a name="l01099"></a>01099                                 <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(vid);
<a name="l01100"></a>01100                                 <span class="keywordflow">if</span> (bvit!=bvitend) {
<a name="l01101"></a>01101                                         bvit-&gt;_commit_modified_subproperties(*pvprop);
<a name="l01102"></a>01102                                 }
<a name="l01103"></a>01103                                 <span class="keyword">delete</span> pvprop;
<a name="l01104"></a>01104                         }
<a name="l01105"></a>01105                         vpropcache.clear();
<a name="l01106"></a>01106                         epropcache.clear();
<a name="l01107"></a>01107                 }
<a name="l01108"></a>01108 <span class="preprocessor">#endif</span>
<a name="l01109"></a>01109 <span class="preprocessor"></span>
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keyword">public</span>:
<a name="l01129"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a876bcf5f9d9fc6c7087c1dba29df2b60">01129</a>                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a876bcf5f9d9fc6c7087c1dba29df2b60">ibm_multiproperty_graph_generic</a>(<span class="keywordtype">string</span> filename, 
<a name="l01130"></a>01130                                                                                 <span class="keywordtype">string</span> path, 
<a name="l01131"></a>01131                                                                                 UINT64 max_memsize=(UINT64)(4294967296),
<a name="l01132"></a>01132                                                                                 <span class="keywordtype">size_t</span> el_blk_sz=DEFAULT_BUNDLE_SZ, 
<a name="l01133"></a>01133                                                                                 <span class="keywordtype">size_t</span> vp_blk_sz=DEFAULT_BUNDLE_SZ, 
<a name="l01134"></a>01134                                                                                 <span class="keywordtype">size_t</span> ep_blk_sz=DEFAULT_BUNDLE_SZ):base_type(filename,path,max_memsize,el_blk_sz, vp_blk_sz, ep_blk_sz){
<a name="l01135"></a>01135                         <span class="keywordflow">if</span> (MPGLOGDEBUG) printf(<span class="stringliteral">&quot;mpg939 filename=%s  path=%s\n&quot;</span>, filename.c_str(), path.c_str());
<a name="l01136"></a>01136                         store_name = path+<span class="stringliteral">&quot;/&quot;</span>+filename;
<a name="l01137"></a>01137                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">_load_keys</a>();
<a name="l01138"></a>01138                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ada5b1f1dea72cfd1845a7de9c581d561">get_or_allocate_epropertyid</a>(<span class="stringliteral">&quot;exid&quot;</span>);  <span class="comment">// externalid</span>
<a name="l01139"></a>01139                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ada5b1f1dea72cfd1845a7de9c581d561">get_or_allocate_epropertyid</a>(<span class="stringliteral">&quot;label&quot;</span>); <span class="comment">// edge label</span>
<a name="l01140"></a>01140                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(<span class="stringliteral">&quot;exid&quot;</span>);  <span class="comment">// externalid</span>
<a name="l01141"></a>01141                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(<span class="stringliteral">&quot;notlabellabellabellabel&quot;</span>); <span class="comment">// hack: don&#39;t use it but want to reserve the second slot in the underlying implementation</span>
<a name="l01142"></a>01142 
<a name="l01148"></a>01148                         std::vector&lt;std::string&gt; indices;
<a name="l01149"></a>01149                         ibmppl::get_indices(path,indices);
<a name="l01150"></a>01150                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;indices.size();i+=2) {
<a name="l01151"></a>01151                                 std::cout&lt;&lt;<span class="stringliteral">&quot;Found index:&quot;</span>&lt;&lt;indices[i]&lt;&lt;<span class="stringliteral">&quot;for property:&quot;</span>&lt;&lt;indices[i+1]&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>; 
<a name="l01152"></a>01152                                 <span class="keywordtype">size_t</span> pos = indices[i].find(<span class="stringliteral">&quot;_multi_index&quot;</span>);
<a name="l01153"></a>01153                                 <span class="keywordflow">if</span> ( pos != std::string::npos) {
<a name="l01154"></a>01154                                         <span class="comment">//add a multi key index; e.g., duplicate keys can exist</span>
<a name="l01155"></a>01155                                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#adfe27ee91e2675dc635bfe01177830a5">add_index</a>(indices[i+1],<span class="keyword">true</span>);
<a name="l01156"></a>01156                                 } <span class="keywordflow">else</span> {
<a name="l01157"></a>01157                                         <span class="comment">//add a unique key index</span>
<a name="l01158"></a>01158                                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#adfe27ee91e2675dc635bfe01177830a5">add_index</a>(indices[i+1], <span class="keyword">false</span>);
<a name="l01159"></a>01159                                 }
<a name="l01160"></a>01160                         }
<a name="l01161"></a>01161                 }
<a name="l01162"></a>01162 
<a name="l01172"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a56e3e8f1364640d4a6da920587c8dbfb">01172</a>                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a56e3e8f1364640d4a6da920587c8dbfb">~ibm_multiproperty_graph_generic</a>() {  <span class="comment">//printf(&quot;mpg266\n&quot;);</span>
<a name="l01173"></a>01173                         <span class="comment">// todo: consider providing a persist method instead.</span>
<a name="l01174"></a>01174                         <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">_save_keys</a>();  <span class="comment">//printf(&quot;mpg269\n&quot;);</span>
<a name="l01175"></a>01175 
<a name="l01176"></a>01176                         <span class="comment">//close and save indices</span>
<a name="l01177"></a>01177                         <span class="keywordflow">for</span> (index_iterator iit = indices.begin();iit != indices.end();++iit) {
<a name="l01178"></a>01178                                 <span class="keywordflow">if</span> ((*iit) != NULL) {
<a name="l01179"></a>01179                                         (*iit)-&gt;free();
<a name="l01180"></a>01180                                 }
<a name="l01181"></a>01181                         }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183                         indices.clear();
<a name="l01184"></a>01184                 }
<a name="l01185"></a>01185 
<a name="l01196"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a47b0d07836428f88f3e1e48818383a7d">01196</a>                 <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a47b0d07836428f88f3e1e48818383a7d">index_available</a>(<span class="keywordtype">size_t</span> propid)<span class="keyword"> const </span>{
<a name="l01197"></a>01197                         <span class="keywordflow">return</span>(propid &lt; indices.size() &amp;&amp; indices[propid]!=NULL);
<a name="l01198"></a>01198                 }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200                 <span class="comment">//vid is output value below; the return of the method tells the</span>
<a name="l01201"></a>01201                 <span class="comment">// success/ fail status for the operation</span>
<a name="l01219"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acaa05cb9f8af76f710f305e3f5996161">01219</a> <span class="comment"></span>                <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acaa05cb9f8af76f710f305e3f5996161">index_find</a>(<span class="keywordtype">int</span> propid, <span class="keyword">const</span> property_value_type&amp; pval, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a>&amp; vid){
<a name="l01220"></a>01220                         <span class="keywordflow">return</span> indices[propid]-&gt;find(pval,vid);
<a name="l01221"></a>01221                 }
<a name="l01222"></a>01222 
<a name="l01241"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a71e996d4d7112230b8949d1a2a744cf8">01241</a>                 <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a71e996d4d7112230b8949d1a2a744cf8">index_find_all</a>(<span class="keywordtype">int</span> propid, <span class="keyword">const</span> property_value_type&amp; pval, std::vector&lt;vertexd_type&gt;&amp; vids){
<a name="l01242"></a>01242                         <span class="keywordflow">return</span> indices[propid]-&gt;find_all(pval, vids);
<a name="l01243"></a>01243                 }
<a name="l01244"></a>01244 
<a name="l01251"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4b463a4e745a692546f6bcc109ff8529">01251</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4b463a4e745a692546f6bcc109ff8529">index_insert</a>(<span class="keywordtype">int</span> propid, <span class="keyword">const</span> property_value_type&amp; pval, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid){
<a name="l01252"></a>01252                         indices[propid]-&gt;insert(pval,vid);
<a name="l01253"></a>01253                 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255                 <span class="keyword">inline</span> <span class="keywordtype">void</span> index_erasexx(<span class="keywordtype">int</span> propid, <span class="keyword">const</span> property_value_type&amp; pval){
<a name="l01256"></a>01256                         indices[propid]-&gt;erase(pval);
<a name="l01257"></a>01257                 }
<a name="l01264"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abc1a1654429cd92cd5006afed26184cc">01264</a>                 <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abc1a1654429cd92cd5006afed26184cc">index_erase</a>(<span class="keywordtype">int</span> propid, <span class="keyword">const</span> property_value_type&amp; pval, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid){
<a name="l01265"></a>01265                         indices[propid]-&gt;erase(pval, vid);
<a name="l01266"></a>01266                 }
<a name="l01267"></a>01267 
<a name="l01291"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#adfe27ee91e2675dc635bfe01177830a5">01291</a>                 <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#adfe27ee91e2675dc635bfe01177830a5">add_index</a>(<span class="keyword">const</span> property_name_type&amp; pname, <span class="keywordtype">bool</span> is_multi=<span class="keyword">false</span>){
<a name="l01292"></a>01292                         <span class="keyword">typedef</span> index&lt;size_t&gt; index_type; <span class="keywordflow">if</span> (MPGLOGDEBUG) { printf(<span class="stringliteral">&quot;mpg1008 add_index( propname=%s, is_multi=%d)\n&quot;</span>, pname.c_str(), (int)is_multi);  }
<a name="l01293"></a>01293                         <span class="keyword">typedef</span> index_multi&lt;size_t&gt; index_multi_type;
<a name="l01294"></a>01294                         <span class="keywordtype">int</span> propid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(pname);
<a name="l01295"></a>01295                         <span class="keyword">typedef</span> index&lt;size_t&gt; index_type;
<a name="l01296"></a>01296                         <span class="keyword">typedef</span> index_multi&lt;size_t&gt; index_multi_type;
<a name="l01297"></a>01297                         <span class="keywordflow">if</span> (propid &gt;= (<span class="keywordtype">int</span>)indices.size()) {
<a name="l01298"></a>01298                                 <span class="comment">//index doesn&#39;t exist; so we will add it;</span>
<a name="l01299"></a>01299                                 indices.resize(propid+1, NULL);
<a name="l01300"></a>01300                         }
<a name="l01301"></a>01301                         <span class="keywordflow">if</span> (indices[propid]==NULL) {
<a name="l01302"></a>01302                                 <span class="keywordflow">if</span> (is_multi) {
<a name="l01303"></a>01303                                         std::string index_name = store_name+<span class="stringliteral">&quot;_multi_index_&quot;</span>+pname;
<a name="l01304"></a>01304                                         indices[propid] = <span class="keyword">new</span> index_multi_type(index_name);
<a name="l01305"></a>01305                                 } <span class="keywordflow">else</span> { <span class="keywordflow">if</span> (MPGLOGDEBUG) { printf(<span class="stringliteral">&quot;mpg1019 created an unique index\n&quot;</span>); fflush(stdout); }
<a name="l01306"></a>01306                                         std::string index_name = store_name+<span class="stringliteral">&quot;_index_&quot;</span>+pname;
<a name="l01307"></a>01307                                         indices[propid] = <span class="keyword">new</span> index_type(index_name);
<a name="l01308"></a>01308                                 }
<a name="l01309"></a>01309                         }
<a name="l01310"></a>01310                         <span class="comment">//else means the index is already present; we don&#39;t do anything </span>
<a name="l01311"></a>01311                 }
<a name="l01312"></a>01312 
<a name="l01318"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abd57a6057ff7ec22358b55ad0759779c">01318</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abd57a6057ff7ec22358b55ad0759779c">set_esubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> eid, <span class="keyword">const</span> property_name_type&amp; pname, property_value_type value){
<a name="l01319"></a>01319       <span class="keywordtype">size_t</span> propid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ada5b1f1dea72cfd1845a7de9c581d561">get_or_allocate_epropertyid</a>(pname);
<a name="l01320"></a>01320       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abd57a6057ff7ec22358b55ad0759779c">set_esubproperty</a>(propid, value);  <span class="comment">// todo: huh?! what is this calling? where is eid used?  Can this method we&#39;re in even be implemented without a vid specified?</span>
<a name="l01321"></a>01321   }
<a name="l01322"></a>01322 
<a name="l01328"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aacfc1a5960fe99558fc81f38866b5d27">01328</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aacfc1a5960fe99558fc81f38866b5d27">set_esubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> eid, <span class="keyword">const</span> <span class="keywordtype">size_t</span> propid, property_value_type value){
<a name="l01329"></a>01329       <a class="code" href="classibmppl_1_1imp__edge__iterator.html">edge_iterator</a> beit = find_edge(eid);  <span class="comment">// todo: what is this method?  Are we even capable of efficiently finding an edge from eid without being given a starting vid?</span>
<a name="l01330"></a>01330       beit-&gt;<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">set_subproperty</a>(propid, value);
<a name="l01331"></a>01331   }
<a name="l01332"></a>01332   
<a name="l01344"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a551ef512e0ab17b89416cbf3fd27c073">01344</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a551ef512e0ab17b89416cbf3fd27c073">set_vsubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid, <span class="keyword">const</span> property_name_type&amp; pname, property_value_type value){
<a name="l01345"></a>01345       <span class="keywordtype">size_t</span> propid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(pname);
<a name="l01346"></a>01346       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a551ef512e0ab17b89416cbf3fd27c073">set_vsubproperty</a>(vid, propid, value); 
<a name="l01347"></a>01347   }
<a name="l01348"></a>01348 
<a name="l01360"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a3251ccb83021b7e2b1773eb50474046b">01360</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a3251ccb83021b7e2b1773eb50474046b">set_vsubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid, <span class="keyword">const</span> <span class="keywordtype">size_t</span> propid, property_value_type value){
<a name="l01361"></a>01361             <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(vid);
<a name="l01362"></a>01362 <span class="preprocessor">            #if 0</span>
<a name="l01363"></a>01363 <span class="preprocessor"></span>            <span class="comment">// commented out by jlc because lower level code handles this</span>
<a name="l01364"></a>01364             <span class="comment">//GABI:: Added index support</span>
<a name="l01365"></a>01365             <span class="keywordflow">if</span> (<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a47b0d07836428f88f3e1e48818383a7d">index_available</a>(propid)) {
<a name="l01366"></a>01366                 <span class="keywordflow">try</span> {
<a name="l01367"></a>01367                     property_value_type old_val = bvit-&gt;<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a> (propid);
<a name="l01368"></a>01368                     <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#abc1a1654429cd92cd5006afed26184cc">index_erase</a>(propid,old_val);
<a name="l01369"></a>01369                 } <span class="keywordflow">catch</span> (...) {
<a name="l01370"></a>01370                 };
<a name="l01371"></a>01371                 <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a4b463a4e745a692546f6bcc109ff8529">index_insert</a>(propid, value, vid);
<a name="l01372"></a>01372             }
<a name="l01373"></a>01373 <span class="preprocessor">            #endif</span>
<a name="l01374"></a>01374 <span class="preprocessor"></span>            bvit-&gt;<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a0f95b86aec12b85815bb59f1157ac1c5">set_subproperty</a>(propid, value);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376   }
<a name="l01377"></a>01377   
<a name="l01393"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a6bbfede650fae251f3d1d87fbe9ed6ed">01393</a>   property_value_type <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a6bbfede650fae251f3d1d87fbe9ed6ed">get_vsubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid, <span class="keyword">const</span> property_name_type&amp; pname){
<a name="l01394"></a>01394       <span class="keywordtype">size_t</span> propid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(pname);
<a name="l01395"></a>01395       <span class="keywordflow">return</span> get_subproperty(vid, propid);
<a name="l01396"></a>01396   }
<a name="l01397"></a>01397 
<a name="l01413"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3661de7e445ceffba24bd5fa84a5f0f">01413</a>   property_value_type <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3661de7e445ceffba24bd5fa84a5f0f">get_vsubproperty</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid, <span class="keywordtype">size_t</span> propid){
<a name="l01414"></a>01414       <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(vid);
<a name="l01415"></a>01415       <span class="keywordflow">return</span> bvit-&gt;<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(propid);
<a name="l01416"></a>01416   }
<a name="l01417"></a>01417   
<a name="l01418"></a>01418 
<a name="l01432"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ada5b1f1dea72cfd1845a7de9c581d561">01432</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ada5b1f1dea72cfd1845a7de9c581d561">get_or_allocate_epropertyid</a>(<span class="keyword">const</span> property_name_type&amp; pname){ <span class="comment">//printf(&quot;mpg302\n&quot;);</span>
<a name="l01433"></a>01433     <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad939a6609c3cb23ce6bd3badee013602">_get_or_alloc_map</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243" title="Similar as above for edges.">epropname_to_id</a>, &amp;id_to_epropname, pname);
<a name="l01434"></a>01434     <span class="keywordflow">return</span> retval;
<a name="l01435"></a>01435   }
<a name="l01436"></a>01436 
<a name="l01452"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">01452</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(<span class="keyword">const</span> property_name_type&amp; pname){
<a name="l01453"></a>01453       <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad939a6609c3cb23ce6bd3badee013602">_get_or_alloc_map</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030" title="Maps a property name to a property id.">vpropname_to_id</a>, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a459899780cffc4fa93ff32bdefa5046b" title="Maps a property id to a property name(string)">id_to_vpropname</a>, pname);
<a name="l01454"></a>01454       <span class="keywordflow">return</span> retval;
<a name="l01455"></a>01455   }
<a name="l01456"></a>01456 
<a name="l01470"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad73d036e8bf37ca71000295f8ee836ba">01470</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad73d036e8bf37ca71000295f8ee836ba">get_or_allocate_labelid</a>(<span class="keyword">const</span> label_string_type&amp; labelstr){
<a name="l01471"></a>01471       <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad939a6609c3cb23ce6bd3badee013602">_get_or_alloc_map</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044" title="Maps a label string to a label id.">label_to_id</a>, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a312cc746c5f826ffb07ea5b667a08055" title="Maps a label id to a label string.">id_to_label</a>, labelstr);
<a name="l01472"></a>01472       <span class="keywordflow">return</span> retval;
<a name="l01473"></a>01473   }
<a name="l01474"></a>01474 
<a name="l01489"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af97912b0216c9cc18642b6e03df45248">01489</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af97912b0216c9cc18642b6e03df45248">get_epropertyid</a>(<span class="keyword">const</span> property_name_type&amp; pname){ <span class="comment">//printf(&quot;mpg302\n&quot;);</span>
<a name="l01490"></a>01490     <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae00f41f45dd6756d247bfeae83fe6c4f">_get_mapping</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243" title="Similar as above for edges.">epropname_to_id</a>, pname);
<a name="l01491"></a>01491     <span class="keywordflow">return</span> retval;
<a name="l01492"></a>01492   }
<a name="l01493"></a>01493 
<a name="l01505"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a53924ea45ee98d86b3ebb12f29abd1ff">01505</a>   <span class="keywordtype">string</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a53924ea45ee98d86b3ebb12f29abd1ff">get_edge_property_name</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> propid)<span class="keyword"> const </span>{
<a name="l01506"></a>01506       <span class="keywordtype">string</span> retval = id_to_epropname.at(propid);
<a name="l01507"></a>01507       <span class="keywordflow">return</span> retval;
<a name="l01508"></a>01508   }
<a name="l01509"></a>01509 
<a name="l01525"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9ea4d619e66ef35716f9d09bd5f9f52c">01525</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9ea4d619e66ef35716f9d09bd5f9f52c">get_vpropertyid</a>(<span class="keyword">const</span> property_name_type&amp; pname){ <span class="comment">//printf(&quot;mpg443 this=0x%lx\n&quot;, (unsigned long)this);</span>
<a name="l01526"></a>01526       <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae00f41f45dd6756d247bfeae83fe6c4f">_get_mapping</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030" title="Maps a property name to a property id.">vpropname_to_id</a>, pname);
<a name="l01527"></a>01527       <span class="keywordflow">return</span> retval;
<a name="l01528"></a>01528   }
<a name="l01529"></a>01529 
<a name="l01541"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a7ba5dc3c83358951c62ad813d9e01ca9">01541</a>   <span class="keywordtype">string</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a7ba5dc3c83358951c62ad813d9e01ca9">get_vertex_property_name</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> propid)<span class="keyword"> const </span>{
<a name="l01542"></a>01542       <span class="keywordtype">string</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a459899780cffc4fa93ff32bdefa5046b" title="Maps a property id to a property name(string)">id_to_vpropname</a>.at(propid);
<a name="l01543"></a>01543       <span class="keywordflow">return</span> retval;
<a name="l01544"></a>01544   }
<a name="l01545"></a>01545 
<a name="l01560"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa8c826d35480481bb11eeabd4932e229">01560</a>   <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa8c826d35480481bb11eeabd4932e229">get_labelid</a>(<span class="keyword">const</span> label_string_type&amp; labelstr){ <span class="comment">//printf(&quot;mpg443 this=0x%lx\n&quot;, (unsigned long)this);</span>
<a name="l01561"></a>01561       <span class="keywordtype">size_t</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae00f41f45dd6756d247bfeae83fe6c4f">_get_mapping</a>(&amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044" title="Maps a label string to a label id.">label_to_id</a>, labelstr);
<a name="l01562"></a>01562       <span class="keywordflow">return</span> retval;
<a name="l01563"></a>01563   }
<a name="l01564"></a>01564 
<a name="l01576"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a146f0eae14d383d8aa28a3d3ad6cf118">01576</a>   <span class="keywordtype">string</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a146f0eae14d383d8aa28a3d3ad6cf118">get_label_string</a>(<span class="keyword">const</span> <span class="keywordtype">size_t</span> labelid)<span class="keyword"> const </span>{
<a name="l01577"></a>01577       <span class="keywordtype">string</span> retval = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a312cc746c5f826ffb07ea5b667a08055" title="Maps a label id to a label string.">id_to_label</a>.at(labelid);
<a name="l01578"></a>01578       <span class="keywordflow">return</span> retval;
<a name="l01579"></a>01579   }
<a name="l01580"></a>01580 
<a name="l01581"></a>01581 
<a name="l01593"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">01593</a>   <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid){
<a name="l01594"></a>01594     base_vertex_iterator bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">base_type::find_vertex</a>(vid);
<a name="l01595"></a>01595     <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a>(bvit, <span class="keyword">this</span>);
<a name="l01596"></a>01596   }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598   
<a name="l01599"></a>01599   edge_iterator find_edge(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> eid) {
<a name="l01600"></a>01600     base_vertex_iterator bvit = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">base_type::find_vertex</a>(vid);
<a name="l01601"></a>01601     <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a> vit(bvit, <span class="keyword">this</span>);
<a name="l01602"></a>01602     edge_iterator eit = vit.edges_begin();
<a name="l01603"></a>01603     <span class="keywordflow">for</span> (; eit != vit.edges_end(); eit++) {
<a name="l01604"></a>01604       <span class="keywordflow">if</span> (eit.id() == (<span class="keywordtype">unsigned</span> long)eid) <span class="keywordflow">break</span>;
<a name="l01605"></a>01605     }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607     <span class="keywordflow">if</span> (eit==vit.edges_end()) {
<a name="l01608"></a>01608         <span class="keywordflow">throw</span> MP_NOT_FOUND;
<a name="l01609"></a>01609     }
<a name="l01610"></a>01610     <span class="keywordflow">return</span> eit;
<a name="l01611"></a>01611   }
<a name="l01612"></a>01612 
<a name="l01631"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a5a1d2ed1c66e0476ca6e950f1d5f7f61">01631</a>   <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a5a1d2ed1c66e0476ca6e950f1d5f7f61">find_vertex</a>(property_name_type&amp; pname, <span class="keyword">const</span> property_value_type&amp; pval) {
<a name="l01632"></a>01632     <span class="comment">//fast path; using an index</span>
<a name="l01633"></a>01633     <a class="code" href="classibmppl_1_1imp__vertex__iterator.html">vertex_iterator</a> retval ;
<a name="l01634"></a>01634     <span class="keywordtype">int</span> propid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#aa1f80df34d13189cd139143144beb15b">get_or_allocate_vpropertyid</a>(pname);
<a name="l01635"></a>01635     <span class="keywordflow">if</span>( <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a47b0d07836428f88f3e1e48818383a7d">index_available</a>(propid) ){
<a name="l01636"></a>01636       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid;
<a name="l01637"></a>01637       <span class="keywordtype">int</span> status = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acaa05cb9f8af76f710f305e3f5996161">index_find</a>(propid, pval, vid);
<a name="l01638"></a>01638       <span class="keywordflow">if</span>(status == INDEX_FOUND){
<a name="l01639"></a>01639         retval = this-&gt;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a632e419e65f3de9ca8b9c2441b718e17">find_vertex</a>(vid);
<a name="l01640"></a>01640         <span class="comment">// correctness check; </span>
<a name="l01641"></a>01641         <span class="comment">// this can be potentially removed from the code path of this method</span>
<a name="l01642"></a>01642         <span class="keywordflow">if</span> (retval.<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(propid)!=pval) {
<a name="l01643"></a>01643           cout&lt;&lt;<span class="stringliteral">&quot;ERROR while using index\n&quot;</span>;
<a name="l01644"></a>01644         }
<a name="l01645"></a>01645         <span class="keywordflow">return</span> retval;
<a name="l01646"></a>01646       }
<a name="l01647"></a>01647     }
<a name="l01648"></a>01648     <span class="comment">//slow path; this may turn a an algorithm easily into O(N^2) or worse</span>
<a name="l01649"></a>01649     retval = vertices_begin();
<a name="l01650"></a>01650     <span class="keywordflow">while</span> (retval!=vertices_end()) {
<a name="l01651"></a>01651       <span class="keywordflow">if</span> (retval.<a class="code" href="classibmppl_1_1imp__graphelement__iterator.html#a6943170108502253c7a4aab3458da32a">get_subproperty</a>(propid)==pval) {
<a name="l01652"></a>01652         <span class="keywordflow">return</span> retval;
<a name="l01653"></a>01653       }
<a name="l01654"></a>01654       retval++;
<a name="l01655"></a>01655     }
<a name="l01656"></a>01656     <span class="keywordflow">return</span> retval;
<a name="l01657"></a>01657   }
<a name="l01658"></a>01658 
<a name="l01659"></a>01659   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a> vertices_begin(){
<a name="l01660"></a>01660     <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a>(base_type::vertices_begin(), <span class="keyword">this</span>);
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a> vertices_end(){
<a name="l01664"></a>01664     <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab0066078c410600f3435c15bfcfb8e27" title="Iterator type for traversing vertices.">vertex_iterator</a>(base_type::vertices_end(), <span class="keyword">this</span>);
<a name="l01665"></a>01665   }
<a name="l01666"></a>01666 
<a name="l01672"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a46e050325495b13327ca69d903293cd7">01672</a>   <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a46e050325495b13327ca69d903293cd7">delete_vertex</a>(<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid) {
<a name="l01673"></a>01673 <span class="preprocessor">      #ifdef CACHING1_SUPPORT</span>
<a name="l01674"></a>01674 <span class="preprocessor"></span>        <span class="comment">// todo: technically we probably should also remove the cache records for in edges and reclaim that memory </span>
<a name="l01675"></a>01675         vpropcache.erase(vid);
<a name="l01676"></a>01676         epropcache.erase(vid);
<a name="l01677"></a>01677 <span class="preprocessor">      #endif</span>
<a name="l01678"></a>01678 <span class="preprocessor"></span>      <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a46e050325495b13327ca69d903293cd7">base_type::delete_vertex</a>(vid);
<a name="l01679"></a>01679   }
<a name="l01680"></a>01680 
<a name="l01692"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a46ae3a543a57a96ea27ff30764013b0e">01692</a>   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a46ae3a543a57a96ea27ff30764013b0e">add_vertex</a>( <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a> vp ) {
<a name="l01693"></a>01693       printf(<span class="stringliteral">&quot;use of this add_vertex method is discouraged\n&quot;</span>);  <span class="comment">// we&#39;d prefer not to expose the underlying implementation to caller.</span>
<a name="l01694"></a>01694       <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af2e6475eb819187d83ce7e45586cd966">base_type::add_vertex</a>(vp);
<a name="l01695"></a>01695   }
<a name="l01696"></a>01696 
<a name="l01704"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af2e6475eb819187d83ce7e45586cd966">01704</a>   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af2e6475eb819187d83ce7e45586cd966">add_vertex</a>() {
<a name="l01705"></a>01705       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a985f321a813dc698f4ee298633172719" title="Property type associated with each vertex.">vertex_property</a> vp;
<a name="l01706"></a>01706       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vid = <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#af2e6475eb819187d83ce7e45586cd966">base_type::add_vertex</a>(vp);  <span class="comment">// there is no other way to add a vertex, so we&#39;re forced to huse this method</span>
<a name="l01707"></a>01707       <span class="keywordflow">return</span> vid;
<a name="l01708"></a>01708   }
<a name="l01709"></a>01709 
<a name="l01722"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a0cb03f2fe1403474b9628a5f2c9a064c">01722</a>   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a0cb03f2fe1403474b9628a5f2c9a064c">add_edge</a>( <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vsource, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vtarget, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b" title="Property type associated with each edge.">edge_property</a> ep ) {
<a name="l01723"></a>01723       printf(<span class="stringliteral">&quot;use of this add_edge method is discouraged\n&quot;</span>);  <span class="comment">// we&#39;d prefer not to expose the underlying implementation to caller.</span>
<a name="l01724"></a>01724       <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a0cb03f2fe1403474b9628a5f2c9a064c">base_type::add_edge</a>(vsource, vtarget, ep);
<a name="l01725"></a>01725   }
<a name="l01726"></a>01726 
<a name="l01734"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a994e008078983dc9b9d14a527f7ae25d">01734</a>   <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab5ff13ad644f26d605c246d48cc66311" title="Directness type. This is either UNDIRECTED, DIRECTED or PRED_DIRECTED.">edged_type</a> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a994e008078983dc9b9d14a527f7ae25d">add_edge</a>( <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vsource, <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a2f63f40158d266adefe063889d0b6371" title="Vertex descriptor. Unique vertex identifier.">vertexd_type</a> vtarget) {
<a name="l01735"></a>01735       <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac19d685e51e6c98e282f5247205c5a6b" title="Property type associated with each edge.">edge_property</a> ep;
<a name="l01736"></a>01736       <span class="keywordflow">return</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a0cb03f2fe1403474b9628a5f2c9a064c">base_type::add_edge</a>(vsource, vtarget, ep);
<a name="l01737"></a>01737   }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739 <span class="keyword">private</span>:
<a name="l01746"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8e8933aa0d7e3c8ee3115d0df83da27d">01746</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a8e8933aa0d7e3c8ee3115d0df83da27d">_load_keys</a>(std::string fn, std::map&lt;std::string, vertexd_type&gt; *vvec, std::vector&lt;std::string&gt; *revmap = 0) {
<a name="l01747"></a>01747         std::fstream f;
<a name="l01748"></a>01748         f.open(fn.c_str(), std::ios::in);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         <span class="keywordflow">if</span> (!f.is_open()) {
<a name="l01751"></a>01751             <span class="comment">// cerr &lt;&lt; &quot;cannot open key file: &quot; &lt;&lt; fn &lt;&lt; endl;                                                                                                                           </span>
<a name="l01752"></a>01752             <span class="comment">// exit(-1);                                                                                                                                                                 </span>
<a name="l01753"></a>01753             <span class="keywordflow">return</span>;
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755 
<a name="l01756"></a>01756         std::string line, key, val;
<a name="l01757"></a>01757         <span class="keywordtype">size_t</span> t;
<a name="l01758"></a>01758         vvec-&gt;clear();
<a name="l01759"></a>01759         <span class="keywordflow">while</span> (f.good()) {
<a name="l01760"></a>01760             getline(f, line);
<a name="l01761"></a>01761             t = line.find(<span class="charliteral">&#39;:&#39;</span>);
<a name="l01762"></a>01762             <span class="keywordflow">if</span> (t == std::string::npos)
<a name="l01763"></a>01763                 <span class="keywordflow">continue</span>;
<a name="l01764"></a>01764             key = line.substr(0, t);
<a name="l01765"></a>01765             val = line.substr(t+1);
<a name="l01766"></a>01766             <span class="keywordtype">int</span> vvv = atoi(val.c_str());
<a name="l01767"></a>01767             vvec[0][key] = vvv;
<a name="l01768"></a>01768             <span class="keywordflow">if</span> (revmap) {
<a name="l01769"></a>01769                 <span class="keywordflow">if</span> (revmap-&gt;size()&lt;(size_t)(vvv+1)) {
<a name="l01770"></a>01770                     revmap-&gt;resize(vvv+1);
<a name="l01771"></a>01771                 }
<a name="l01772"></a>01772                 revmap[0][vvv] = key;
<a name="l01773"></a>01773             }
<a name="l01774"></a>01774             <span class="comment">// cout &lt;&lt; &quot;I am loading: key, val = [&quot; &lt;&lt; key &lt;&lt; &quot;], [&quot; &lt;&lt; val &lt;&lt; &quot;]&quot; &lt;&lt; endl;                                                                                              </span>
<a name="l01775"></a>01775         }
<a name="l01776"></a>01776         f.close();
<a name="l01777"></a>01777     }
<a name="l01778"></a>01778 
<a name="l01785"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">01785</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">_load_keys</a>() {
<a name="l01786"></a>01786 <span class="preprocessor">        #if 1</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span>            std::string fn = store_name + std::string(<span class="stringliteral">&quot;.labelstrings&quot;</span>);
<a name="l01788"></a>01788             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">_load_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044" title="Maps a label string to a label id.">label_to_id</a>, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a312cc746c5f826ffb07ea5b667a08055" title="Maps a label id to a label string.">id_to_label</a>);
<a name="l01789"></a>01789             fn = store_name + std::string(<span class="stringliteral">&quot;.vpropnames&quot;</span>);
<a name="l01790"></a>01790             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">_load_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030" title="Maps a property name to a property id.">vpropname_to_id</a>, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a459899780cffc4fa93ff32bdefa5046b" title="Maps a property id to a property name(string)">id_to_vpropname</a>);
<a name="l01791"></a>01791             fn = store_name + std::string(<span class="stringliteral">&quot;.epropnames&quot;</span>);
<a name="l01792"></a>01792             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad7022f47d5184f60522b8b4c01fcc5f1">_load_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243" title="Similar as above for edges.">epropname_to_id</a>, &amp;id_to_epropname);
<a name="l01793"></a>01793 <span class="preprocessor">        #else</span>
<a name="l01794"></a>01794 <span class="preprocessor"></span><span class="preprocessor">            #warning &quot;todo: have to uncomment this for persistent implementation&quot;</span>
<a name="l01795"></a>01795 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l01796"></a>01796 <span class="preprocessor"></span>    }
<a name="l01797"></a>01797 
<a name="l01804"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9ae28beffd6a733b9d61b98a9c19414f">01804</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a9ae28beffd6a733b9d61b98a9c19414f">_save_keys</a>(std::string fn, std::map&lt;std::string, vertexd_type&gt; *vvec) {
<a name="l01805"></a>01805         std::fstream f;
<a name="l01806"></a>01806         f.open(fn.c_str(), std::ios::out);
<a name="l01807"></a>01807         <span class="keywordflow">if</span> (!f.is_open()) {
<a name="l01808"></a>01808             std::cerr &lt;&lt; <span class="stringliteral">&quot;cannot open key file: &quot;</span> &lt;&lt; fn &lt;&lt; std::endl;
<a name="l01809"></a>01809             exit(-1);
<a name="l01810"></a>01810         }
<a name="l01811"></a>01811 
<a name="l01812"></a>01812         <span class="keywordflow">for</span> (std::map&lt;std::string,size_t&gt;::iterator it=vvec-&gt;begin(); it!=vvec-&gt;end(); it++) {
<a name="l01813"></a>01813             f &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;
<a name="l01814"></a>01814         }
<a name="l01815"></a>01815         f.close();
<a name="l01816"></a>01816     }
<a name="l01817"></a>01817 
<a name="l01824"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">01824</a>     <span class="keywordtype">void</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">_save_keys</a>() {
<a name="l01825"></a>01825 <span class="preprocessor">        #if 1</span>
<a name="l01826"></a>01826 <span class="preprocessor"></span>            std::string fn = store_name + std::string(<span class="stringliteral">&quot;.labelstrings&quot;</span>);
<a name="l01827"></a>01827             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">_save_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ab3f5afe6cbeb252dca86acc1f05c9044" title="Maps a label string to a label id.">label_to_id</a>);
<a name="l01828"></a>01828             fn = store_name + std::string(<span class="stringliteral">&quot;.vpropnames&quot;</span>);
<a name="l01829"></a>01829             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">_save_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ac3e0603c044ae76130c7bba110d1e030" title="Maps a property name to a property id.">vpropname_to_id</a>);
<a name="l01830"></a>01830             fn = store_name + std::string(<span class="stringliteral">&quot;.epropnames&quot;</span>);
<a name="l01831"></a>01831             <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#acada190c7f558eac5b9947dee59064ce">_save_keys</a>(fn, &amp;<a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#a155c3ffa3239a7deac2bcf7a10e30243" title="Similar as above for edges.">epropname_to_id</a>);
<a name="l01832"></a>01832 <span class="preprocessor">        #else</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span><span class="preprocessor">            #warning &quot;todo: have to uncomment this for persistent implementation&quot;</span>
<a name="l01834"></a>01834 <span class="preprocessor"></span><span class="preprocessor">        #endif</span>
<a name="l01835"></a>01835 <span class="preprocessor"></span>    }
<a name="l01836"></a>01836 
<a name="l01844"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad939a6609c3cb23ce6bd3badee013602">01844</a>     <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ad939a6609c3cb23ce6bd3badee013602">_get_or_alloc_map</a>( std::map&lt;std::string, vertexd_type&gt; * mapin, std::vector&lt;std::string&gt; * vecin, std::string keystring)
<a name="l01845"></a>01845     {
<a name="l01846"></a>01846         <span class="keywordtype">int</span> id;
<a name="l01847"></a>01847         <span class="keywordflow">try</span> {  <span class="comment">//printf(&quot;mpg418\n&quot;);</span>
<a name="l01848"></a>01848             <span class="keywordtype">id</span> = mapin-&gt;at(keystring);
<a name="l01849"></a>01849             <span class="comment">//} catch ( const std::out_of_range&amp; oor) {</span>
<a name="l01850"></a>01850         } <span class="keywordflow">catch</span> ( ... ) {
<a name="l01851"></a>01851             <span class="comment">//printf(&quot;  size is %d\n&quot;, (int)vecin-&gt;size());</span>
<a name="l01852"></a>01852             <span class="keywordtype">size_t</span> sz = vecin-&gt;size();
<a name="l01853"></a>01853             vecin-&gt;resize(sz+1);
<a name="l01854"></a>01854             <span class="comment">//printf(&quot;  size is %d\n&quot;, (int)vecin-&gt;size());</span>
<a name="l01855"></a>01855             <span class="keywordtype">id</span> = sz;
<a name="l01856"></a>01856             vecin[0][id] = keystring;
<a name="l01857"></a>01857             <span class="comment">//printf(&quot;  size is %d\n&quot;, (int)vecin-&gt;size());</span>
<a name="l01858"></a>01858             mapin[0][keystring] = id;
<a name="l01859"></a>01859         }
<a name="l01860"></a>01860         <span class="keywordflow">return</span> id;
<a name="l01861"></a>01861     }
<a name="l01862"></a>01862 
<a name="l01871"></a><a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae00f41f45dd6756d247bfeae83fe6c4f">01871</a>     <span class="keywordtype">size_t</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html#ae00f41f45dd6756d247bfeae83fe6c4f">_get_mapping</a>( std::map&lt;std::string, vertexd_type&gt; * mapin, std::string keystring)
<a name="l01872"></a>01872     {
<a name="l01873"></a>01873         <span class="keywordflow">try</span> {  <span class="comment">//printf(&quot;mpg573 map=0x%lx\n&quot;, (unsigned long)mapin);</span>
<a name="l01874"></a>01874             <span class="keywordtype">int</span> <span class="keywordtype">id</span> = mapin-&gt;at(keystring);
<a name="l01875"></a>01875             <span class="keywordflow">return</span> id;
<a name="l01876"></a>01876         <span class="comment">//} catch ( const std::out_of_range&amp; oor) {</span>
<a name="l01877"></a>01877         } <span class="keywordflow">catch</span> ( ... ) { <span class="comment">//printf(&quot;mpg577\n&quot;);</span>
<a name="l01878"></a>01878             <span class="keywordflow">throw</span> MP_NOT_FOUND;
<a name="l01879"></a>01879         }
<a name="l01880"></a>01880     }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 
<a name="l01884"></a>01884   };<span class="comment">//end graph class</span>
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 
<a name="l01887"></a>01887   <span class="keyword">typedef</span> <a class="code" href="classibmppl_1_1ibm__multiproperty__graph__generic.html">ibmppl::ibm_multiproperty_graph_generic&lt;tabular_multiproperty_type, tabular_multiproperty_type, ibmppl::PRED_DIRECTED&gt;</a> ibm_multiproperty_graph;
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 
<a name="l01890"></a>01890 }<span class="comment">//end namespace ibmppl</span>
<a name="l01891"></a>01891 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
